{"ast":null,"code":"var __generator = this && this.__generator || function (thisArg, body) {\n  var _ = {\n      label: 0,\n      sent: function () {\n        if (t[0] & 1) throw t[1];\n        return t[1];\n      },\n      trys: [],\n      ops: []\n    },\n    f,\n    y,\n    t,\n    g;\n  return g = {\n    next: verb(0),\n    \"throw\": verb(1),\n    \"return\": verb(2)\n  }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function () {\n    return this;\n  }), g;\n  function verb(n) {\n    return function (v) {\n      return step([n, v]);\n    };\n  }\n  function step(op) {\n    if (f) throw new TypeError(\"Generator is already executing.\");\n    while (_) try {\n      if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n      if (y = 0, t) op = [op[0] & 2, t.value];\n      switch (op[0]) {\n        case 0:\n        case 1:\n          t = op;\n          break;\n        case 4:\n          _.label++;\n          return {\n            value: op[1],\n            done: false\n          };\n        case 5:\n          _.label++;\n          y = op[1];\n          op = [0];\n          continue;\n        case 7:\n          op = _.ops.pop();\n          _.trys.pop();\n          continue;\n        default:\n          if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {\n            _ = 0;\n            continue;\n          }\n          if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {\n            _.label = op[1];\n            break;\n          }\n          if (op[0] === 6 && _.label < t[1]) {\n            _.label = t[1];\n            t = op;\n            break;\n          }\n          if (t && _.label < t[2]) {\n            _.label = t[2];\n            _.ops.push(op);\n            break;\n          }\n          if (t[2]) _.ops.pop();\n          _.trys.pop();\n          continue;\n      }\n      op = body.call(thisArg, _);\n    } catch (e) {\n      op = [6, e];\n      y = 0;\n    } finally {\n      f = t = 0;\n    }\n    if (op[0] & 5) throw op[1];\n    return {\n      value: op[0] ? op[1] : void 0,\n      done: true\n    };\n  }\n};\nvar __spreadArray = this && this.__spreadArray || function (to, from) {\n  for (var i = 0, il = from.length, j = to.length; i < il; i++, j++) to[j] = from[i];\n  return to;\n};\nvar __defProp = Object.defineProperty;\nvar __defProps = Object.defineProperties;\nvar __getOwnPropDescs = Object.getOwnPropertyDescriptors;\nvar __getOwnPropSymbols = Object.getOwnPropertySymbols;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __propIsEnum = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp = function (obj, key, value) {\n  return key in obj ? __defProp(obj, key, {\n    enumerable: true,\n    configurable: true,\n    writable: true,\n    value: value\n  }) : obj[key] = value;\n};\nvar __spreadValues = function (a, b) {\n  for (var prop in b || (b = {})) if (__hasOwnProp.call(b, prop)) __defNormalProp(a, prop, b[prop]);\n  if (__getOwnPropSymbols) for (var _j = 0, _k = __getOwnPropSymbols(b); _j < _k.length; _j++) {\n    var prop = _k[_j];\n    if (__propIsEnum.call(b, prop)) __defNormalProp(a, prop, b[prop]);\n  }\n  return a;\n};\nvar __spreadProps = function (a, b) {\n  return __defProps(a, __getOwnPropDescs(b));\n};\nvar __objRest = function (source, exclude) {\n  var target = {};\n  for (var prop in source) if (__hasOwnProp.call(source, prop) && exclude.indexOf(prop) < 0) target[prop] = source[prop];\n  if (source != null && __getOwnPropSymbols) for (var _j = 0, _k = __getOwnPropSymbols(source); _j < _k.length; _j++) {\n    var prop = _k[_j];\n    if (exclude.indexOf(prop) < 0 && __propIsEnum.call(source, prop)) target[prop] = source[prop];\n  }\n  return target;\n};\nvar __async = function (__this, __arguments, generator) {\n  return new Promise(function (resolve, reject) {\n    var fulfilled = function (value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    };\n    var rejected = function (value) {\n      try {\n        step(generator.throw(value));\n      } catch (e) {\n        reject(e);\n      }\n    };\n    var step = function (x) {\n      return x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);\n    };\n    step((generator = generator.apply(__this, __arguments)).next());\n  });\n};\n// src/query/core/apiState.ts\nvar QueryStatus;\n(function (QueryStatus2) {\n  QueryStatus2[\"uninitialized\"] = \"uninitialized\";\n  QueryStatus2[\"pending\"] = \"pending\";\n  QueryStatus2[\"fulfilled\"] = \"fulfilled\";\n  QueryStatus2[\"rejected\"] = \"rejected\";\n})(QueryStatus || (QueryStatus = {}));\nfunction getRequestStatusFlags(status) {\n  return {\n    status: status,\n    isUninitialized: status === QueryStatus.uninitialized,\n    isLoading: status === QueryStatus.pending,\n    isSuccess: status === QueryStatus.fulfilled,\n    isError: status === QueryStatus.rejected\n  };\n}\n// src/query/utils/isAbsoluteUrl.ts\nfunction isAbsoluteUrl(url) {\n  return new RegExp(\"(^|:)//\").test(url);\n}\n// src/query/utils/joinUrls.ts\nvar withoutTrailingSlash = function (url) {\n  return url.replace(/\\/$/, \"\");\n};\nvar withoutLeadingSlash = function (url) {\n  return url.replace(/^\\//, \"\");\n};\nfunction joinUrls(base, url) {\n  if (!base) {\n    return url;\n  }\n  if (!url) {\n    return base;\n  }\n  if (isAbsoluteUrl(url)) {\n    return url;\n  }\n  var delimiter = base.endsWith(\"/\") || !url.startsWith(\"?\") ? \"/\" : \"\";\n  base = withoutTrailingSlash(base);\n  url = withoutLeadingSlash(url);\n  return \"\" + base + delimiter + url;\n}\n// src/query/utils/flatten.ts\nvar flatten = function (arr) {\n  return [].concat.apply([], arr);\n};\n// src/query/utils/isOnline.ts\nfunction isOnline() {\n  return typeof navigator === \"undefined\" ? true : navigator.onLine === void 0 ? true : navigator.onLine;\n}\n// src/query/utils/isDocumentVisible.ts\nfunction isDocumentVisible() {\n  if (typeof document === \"undefined\") {\n    return true;\n  }\n  return document.visibilityState !== \"hidden\";\n}\n// src/query/utils/copyWithStructuralSharing.ts\nimport { isPlainObject as _iPO } from \"@reduxjs/toolkit\";\nvar isPlainObject = _iPO;\nfunction copyWithStructuralSharing(oldObj, newObj) {\n  if (oldObj === newObj || !(isPlainObject(oldObj) && isPlainObject(newObj) || Array.isArray(oldObj) && Array.isArray(newObj))) {\n    return newObj;\n  }\n  var newKeys = Object.keys(newObj);\n  var oldKeys = Object.keys(oldObj);\n  var isSameObject = newKeys.length === oldKeys.length;\n  var mergeObj = Array.isArray(newObj) ? [] : {};\n  for (var _j = 0, newKeys_1 = newKeys; _j < newKeys_1.length; _j++) {\n    var key = newKeys_1[_j];\n    mergeObj[key] = copyWithStructuralSharing(oldObj[key], newObj[key]);\n    if (isSameObject) isSameObject = oldObj[key] === mergeObj[key];\n  }\n  return isSameObject ? oldObj : mergeObj;\n}\n// src/query/fetchBaseQuery.ts\nimport { isPlainObject as isPlainObject2 } from \"@reduxjs/toolkit\";\nvar defaultFetchFn = function () {\n  var args = [];\n  for (var _j = 0; _j < arguments.length; _j++) {\n    args[_j] = arguments[_j];\n  }\n  return fetch.apply(void 0, args);\n};\nvar defaultValidateStatus = function (response) {\n  return response.status >= 200 && response.status <= 299;\n};\nvar defaultIsJsonContentType = function (headers) {\n  return /ion\\/(vnd\\.api\\+)?json/.test(headers.get(\"content-type\") || \"\");\n};\nfunction stripUndefined(obj) {\n  if (!isPlainObject2(obj)) {\n    return obj;\n  }\n  var copy = __spreadValues({}, obj);\n  for (var _j = 0, _k = Object.entries(copy); _j < _k.length; _j++) {\n    var _l = _k[_j],\n      k = _l[0],\n      v = _l[1];\n    if (v === void 0) delete copy[k];\n  }\n  return copy;\n}\nfunction fetchBaseQuery(_a) {\n  var _this = this;\n  if (_a === void 0) {\n    _a = {};\n  }\n  var _b = _a,\n    baseUrl = _b.baseUrl,\n    _j = _b.prepareHeaders,\n    prepareHeaders = _j === void 0 ? function (x) {\n      return x;\n    } : _j,\n    _k = _b.fetchFn,\n    fetchFn = _k === void 0 ? defaultFetchFn : _k,\n    paramsSerializer = _b.paramsSerializer,\n    _l = _b.isJsonContentType,\n    isJsonContentType = _l === void 0 ? defaultIsJsonContentType : _l,\n    _m = _b.jsonContentType,\n    jsonContentType = _m === void 0 ? \"application/json\" : _m,\n    jsonReplacer = _b.jsonReplacer,\n    defaultTimeout = _b.timeout,\n    globalResponseHandler = _b.responseHandler,\n    globalValidateStatus = _b.validateStatus,\n    baseFetchOptions = __objRest(_b, [\"baseUrl\", \"prepareHeaders\", \"fetchFn\", \"paramsSerializer\", \"isJsonContentType\", \"jsonContentType\", \"jsonReplacer\", \"timeout\", \"responseHandler\", \"validateStatus\"]);\n  if (typeof fetch === \"undefined\" && fetchFn === defaultFetchFn) {\n    console.warn(\"Warning: `fetch` is not available. Please supply a custom `fetchFn` property to use `fetchBaseQuery` on SSR environments.\");\n  }\n  return function (arg, api) {\n    return __async(_this, null, function () {\n      var signal, getState, extra, endpoint, forced, type, meta, _a2, url, _j, headers, _k, params, _l, responseHandler, _m, validateStatus, _o, timeout, rest, config, _p, isJsonifiable, divider, query, request, requestClone, response, timedOut, timeoutId, e_1, responseClone, resultData, responseText, handleResponseError_1, e_2;\n      return __generator(this, function (_q) {\n        switch (_q.label) {\n          case 0:\n            signal = api.signal, getState = api.getState, extra = api.extra, endpoint = api.endpoint, forced = api.forced, type = api.type;\n            _a2 = typeof arg == \"string\" ? {\n              url: arg\n            } : arg, url = _a2.url, _j = _a2.headers, headers = _j === void 0 ? new Headers(baseFetchOptions.headers) : _j, _k = _a2.params, params = _k === void 0 ? void 0 : _k, _l = _a2.responseHandler, responseHandler = _l === void 0 ? globalResponseHandler != null ? globalResponseHandler : \"json\" : _l, _m = _a2.validateStatus, validateStatus = _m === void 0 ? globalValidateStatus != null ? globalValidateStatus : defaultValidateStatus : _m, _o = _a2.timeout, timeout = _o === void 0 ? defaultTimeout : _o, rest = __objRest(_a2, [\"url\", \"headers\", \"params\", \"responseHandler\", \"validateStatus\", \"timeout\"]);\n            config = __spreadValues(__spreadProps(__spreadValues({}, baseFetchOptions), {\n              signal: signal\n            }), rest);\n            headers = new Headers(stripUndefined(headers));\n            _p = config;\n            return [4 /*yield*/, prepareHeaders(headers, {\n              getState: getState,\n              extra: extra,\n              endpoint: endpoint,\n              forced: forced,\n              type: type\n            })];\n          case 1:\n            _p.headers = _q.sent() || headers;\n            isJsonifiable = function (body) {\n              return typeof body === \"object\" && (isPlainObject2(body) || Array.isArray(body) || typeof body.toJSON === \"function\");\n            };\n            if (!config.headers.has(\"content-type\") && isJsonifiable(config.body)) {\n              config.headers.set(\"content-type\", jsonContentType);\n            }\n            if (isJsonifiable(config.body) && isJsonContentType(config.headers)) {\n              config.body = JSON.stringify(config.body, jsonReplacer);\n            }\n            if (params) {\n              divider = ~url.indexOf(\"?\") ? \"&\" : \"?\";\n              query = paramsSerializer ? paramsSerializer(params) : new URLSearchParams(stripUndefined(params));\n              url += divider + query;\n            }\n            url = joinUrls(baseUrl, url);\n            request = new Request(url, config);\n            requestClone = new Request(url, config);\n            meta = {\n              request: requestClone\n            };\n            timedOut = false, timeoutId = timeout && setTimeout(function () {\n              timedOut = true;\n              api.abort();\n            }, timeout);\n            _q.label = 2;\n          case 2:\n            _q.trys.push([2, 4, 5, 6]);\n            return [4 /*yield*/, fetchFn(request)];\n          case 3:\n            response = _q.sent();\n            return [3 /*break*/, 6];\n          case 4:\n            e_1 = _q.sent();\n            return [2 /*return*/, {\n              error: {\n                status: timedOut ? \"TIMEOUT_ERROR\" : \"FETCH_ERROR\",\n                error: String(e_1)\n              },\n              meta: meta\n            }];\n          case 5:\n            if (timeoutId) clearTimeout(timeoutId);\n            return [7 /*endfinally*/];\n          case 6:\n            responseClone = response.clone();\n            meta.response = responseClone;\n            responseText = \"\";\n            _q.label = 7;\n          case 7:\n            _q.trys.push([7, 9,, 10]);\n            return [4 /*yield*/, Promise.all([handleResponse(response, responseHandler).then(function (r) {\n              return resultData = r;\n            }, function (e) {\n              return handleResponseError_1 = e;\n            }), responseClone.text().then(function (r) {\n              return responseText = r;\n            }, function () {})])];\n          case 8:\n            _q.sent();\n            if (handleResponseError_1) throw handleResponseError_1;\n            return [3 /*break*/, 10];\n          case 9:\n            e_2 = _q.sent();\n            return [2 /*return*/, {\n              error: {\n                status: \"PARSING_ERROR\",\n                originalStatus: response.status,\n                data: responseText,\n                error: String(e_2)\n              },\n              meta: meta\n            }];\n          case 10:\n            return [2 /*return*/, validateStatus(response, resultData) ? {\n              data: resultData,\n              meta: meta\n            } : {\n              error: {\n                status: response.status,\n                data: resultData\n              },\n              meta: meta\n            }];\n        }\n      });\n    });\n  };\n  function handleResponse(response, responseHandler) {\n    return __async(this, null, function () {\n      var text;\n      return __generator(this, function (_j) {\n        switch (_j.label) {\n          case 0:\n            if (typeof responseHandler === \"function\") {\n              return [2 /*return*/, responseHandler(response)];\n            }\n            if (responseHandler === \"content-type\") {\n              responseHandler = isJsonContentType(response.headers) ? \"json\" : \"text\";\n            }\n            if (!(responseHandler === \"json\")) return [3 /*break*/, 2];\n            return [4 /*yield*/, response.text()];\n          case 1:\n            text = _j.sent();\n            return [2 /*return*/, text.length ? JSON.parse(text) : null];\n          case 2:\n            return [2 /*return*/, response.text()];\n        }\n      });\n    });\n  }\n}\n// src/query/HandledError.ts\nvar HandledError = /** @class */function () {\n  function HandledError(value, meta) {\n    if (meta === void 0) {\n      meta = void 0;\n    }\n    this.value = value;\n    this.meta = meta;\n  }\n  return HandledError;\n}();\n// src/query/retry.ts\nfunction defaultBackoff(attempt, maxRetries) {\n  if (attempt === void 0) {\n    attempt = 0;\n  }\n  if (maxRetries === void 0) {\n    maxRetries = 5;\n  }\n  return __async(this, null, function () {\n    var attempts, timeout;\n    return __generator(this, function (_j) {\n      switch (_j.label) {\n        case 0:\n          attempts = Math.min(attempt, maxRetries);\n          timeout = ~~((Math.random() + 0.4) * (300 << attempts));\n          return [4 /*yield*/, new Promise(function (resolve) {\n            return setTimeout(function (res) {\n              return resolve(res);\n            }, timeout);\n          })];\n        case 1:\n          _j.sent();\n          return [2 /*return*/];\n      }\n    });\n  });\n}\nfunction fail(e) {\n  throw Object.assign(new HandledError({\n    error: e\n  }), {\n    throwImmediately: true\n  });\n}\nvar EMPTY_OPTIONS = {};\nvar retryWithBackoff = function (baseQuery, defaultOptions) {\n  return function (args, api, extraOptions) {\n    return __async(void 0, null, function () {\n      var possibleMaxRetries, maxRetries, defaultRetryCondition, options, retry2, result, e_3;\n      return __generator(this, function (_j) {\n        switch (_j.label) {\n          case 0:\n            possibleMaxRetries = [5, (defaultOptions || EMPTY_OPTIONS).maxRetries, (extraOptions || EMPTY_OPTIONS).maxRetries].filter(function (x) {\n              return x !== void 0;\n            });\n            maxRetries = possibleMaxRetries.slice(-1)[0];\n            defaultRetryCondition = function (_, __, _j) {\n              var attempt = _j.attempt;\n              return attempt <= maxRetries;\n            };\n            options = __spreadValues(__spreadValues({\n              maxRetries: maxRetries,\n              backoff: defaultBackoff,\n              retryCondition: defaultRetryCondition\n            }, defaultOptions), extraOptions);\n            retry2 = 0;\n            _j.label = 1;\n          case 1:\n            if (!true) return [3 /*break*/, 7];\n            _j.label = 2;\n          case 2:\n            _j.trys.push([2, 4,, 6]);\n            return [4 /*yield*/, baseQuery(args, api, extraOptions)];\n          case 3:\n            result = _j.sent();\n            if (result.error) {\n              throw new HandledError(result);\n            }\n            return [2 /*return*/, result];\n          case 4:\n            e_3 = _j.sent();\n            retry2++;\n            if (e_3.throwImmediately) {\n              if (e_3 instanceof HandledError) {\n                return [2 /*return*/, e_3.value];\n              }\n              throw e_3;\n            }\n            if (e_3 instanceof HandledError && !options.retryCondition(e_3.value.error, args, {\n              attempt: retry2,\n              baseQueryApi: api,\n              extraOptions: extraOptions\n            })) {\n              return [2 /*return*/, e_3.value];\n            }\n            return [4 /*yield*/, options.backoff(retry2, options.maxRetries)];\n          case 5:\n            _j.sent();\n            return [3 /*break*/, 6];\n          case 6:\n            return [3 /*break*/, 1];\n          case 7:\n            return [2 /*return*/];\n        }\n      });\n    });\n  };\n};\nvar retry = /* @__PURE__ */Object.assign(retryWithBackoff, {\n  fail: fail\n});\n// src/query/core/setupListeners.ts\nimport { createAction } from \"@reduxjs/toolkit\";\nvar onFocus = /* @__PURE__ */createAction(\"__rtkq/focused\");\nvar onFocusLost = /* @__PURE__ */createAction(\"__rtkq/unfocused\");\nvar onOnline = /* @__PURE__ */createAction(\"__rtkq/online\");\nvar onOffline = /* @__PURE__ */createAction(\"__rtkq/offline\");\nvar initialized = false;\nfunction setupListeners(dispatch, customHandler) {\n  function defaultHandler() {\n    var handleFocus = function () {\n      return dispatch(onFocus());\n    };\n    var handleFocusLost = function () {\n      return dispatch(onFocusLost());\n    };\n    var handleOnline = function () {\n      return dispatch(onOnline());\n    };\n    var handleOffline = function () {\n      return dispatch(onOffline());\n    };\n    var handleVisibilityChange = function () {\n      if (window.document.visibilityState === \"visible\") {\n        handleFocus();\n      } else {\n        handleFocusLost();\n      }\n    };\n    if (!initialized) {\n      if (typeof window !== \"undefined\" && window.addEventListener) {\n        window.addEventListener(\"visibilitychange\", handleVisibilityChange, false);\n        window.addEventListener(\"focus\", handleFocus, false);\n        window.addEventListener(\"online\", handleOnline, false);\n        window.addEventListener(\"offline\", handleOffline, false);\n        initialized = true;\n      }\n    }\n    var unsubscribe = function () {\n      window.removeEventListener(\"focus\", handleFocus);\n      window.removeEventListener(\"visibilitychange\", handleVisibilityChange);\n      window.removeEventListener(\"online\", handleOnline);\n      window.removeEventListener(\"offline\", handleOffline);\n      initialized = false;\n    };\n    return unsubscribe;\n  }\n  return customHandler ? customHandler(dispatch, {\n    onFocus: onFocus,\n    onFocusLost: onFocusLost,\n    onOffline: onOffline,\n    onOnline: onOnline\n  }) : defaultHandler();\n}\n// src/query/core/buildSelectors.ts\nimport { createNextState as createNextState2, createSelector } from \"@reduxjs/toolkit\";\n// src/query/endpointDefinitions.ts\nvar DefinitionType;\n(function (DefinitionType2) {\n  DefinitionType2[\"query\"] = \"query\";\n  DefinitionType2[\"mutation\"] = \"mutation\";\n})(DefinitionType || (DefinitionType = {}));\nfunction isQueryDefinition(e) {\n  return e.type === DefinitionType.query;\n}\nfunction isMutationDefinition(e) {\n  return e.type === DefinitionType.mutation;\n}\nfunction calculateProvidedBy(description, result, error, queryArg, meta, assertTagTypes) {\n  if (isFunction(description)) {\n    return description(result, error, queryArg, meta).map(expandTagDescription).map(assertTagTypes);\n  }\n  if (Array.isArray(description)) {\n    return description.map(expandTagDescription).map(assertTagTypes);\n  }\n  return [];\n}\nfunction isFunction(t) {\n  return typeof t === \"function\";\n}\nfunction expandTagDescription(description) {\n  return typeof description === \"string\" ? {\n    type: description\n  } : description;\n}\n// src/query/core/buildSlice.ts\nimport { combineReducers, createAction as createAction2, createSlice, isAnyOf, isFulfilled as isFulfilled2, isRejectedWithValue as isRejectedWithValue2, createNextState, prepareAutoBatched } from \"@reduxjs/toolkit\";\n// src/query/utils/isNotNullish.ts\nfunction isNotNullish(v) {\n  return v != null;\n}\n// src/query/core/buildInitiate.ts\nvar forceQueryFnSymbol = Symbol(\"forceQueryFn\");\nvar isUpsertQuery = function (arg) {\n  return typeof arg[forceQueryFnSymbol] === \"function\";\n};\nfunction buildInitiate(_j) {\n  var serializeQueryArgs = _j.serializeQueryArgs,\n    queryThunk = _j.queryThunk,\n    mutationThunk = _j.mutationThunk,\n    api = _j.api,\n    context = _j.context;\n  var runningQueries = new Map();\n  var runningMutations = new Map();\n  var _k = api.internalActions,\n    unsubscribeQueryResult = _k.unsubscribeQueryResult,\n    removeMutationResult = _k.removeMutationResult,\n    updateSubscriptionOptions = _k.updateSubscriptionOptions;\n  return {\n    buildInitiateQuery: buildInitiateQuery,\n    buildInitiateMutation: buildInitiateMutation,\n    getRunningQueryThunk: getRunningQueryThunk,\n    getRunningMutationThunk: getRunningMutationThunk,\n    getRunningQueriesThunk: getRunningQueriesThunk,\n    getRunningMutationsThunk: getRunningMutationsThunk,\n    getRunningOperationPromises: getRunningOperationPromises,\n    removalWarning: removalWarning\n  };\n  function removalWarning() {\n    throw new Error(\"This method had to be removed due to a conceptual bug in RTK.\\n       Please see https://github.com/reduxjs/redux-toolkit/pull/2481 for details.\\n       See https://redux-toolkit.js.org/rtk-query/usage/server-side-rendering for new guidance on SSR.\");\n  }\n  function getRunningOperationPromises() {\n    if (typeof process !== \"undefined\" && process.env.NODE_ENV === \"development\") {\n      removalWarning();\n    } else {\n      var extract = function (v) {\n        return Array.from(v.values()).flatMap(function (queriesForStore) {\n          return queriesForStore ? Object.values(queriesForStore) : [];\n        });\n      };\n      return __spreadArray(__spreadArray([], extract(runningQueries)), extract(runningMutations)).filter(isNotNullish);\n    }\n  }\n  function getRunningQueryThunk(endpointName, queryArgs) {\n    return function (dispatch) {\n      var _a;\n      var endpointDefinition = context.endpointDefinitions[endpointName];\n      var queryCacheKey = serializeQueryArgs({\n        queryArgs: queryArgs,\n        endpointDefinition: endpointDefinition,\n        endpointName: endpointName\n      });\n      return (_a = runningQueries.get(dispatch)) == null ? void 0 : _a[queryCacheKey];\n    };\n  }\n  function getRunningMutationThunk(_endpointName, fixedCacheKeyOrRequestId) {\n    return function (dispatch) {\n      var _a;\n      return (_a = runningMutations.get(dispatch)) == null ? void 0 : _a[fixedCacheKeyOrRequestId];\n    };\n  }\n  function getRunningQueriesThunk() {\n    return function (dispatch) {\n      return Object.values(runningQueries.get(dispatch) || {}).filter(isNotNullish);\n    };\n  }\n  function getRunningMutationsThunk() {\n    return function (dispatch) {\n      return Object.values(runningMutations.get(dispatch) || {}).filter(isNotNullish);\n    };\n  }\n  function middlewareWarning(dispatch) {\n    if (process.env.NODE_ENV !== \"production\") {\n      if (middlewareWarning.triggered) return;\n      var registered = dispatch(api.internalActions.internal_probeSubscription({\n        queryCacheKey: \"DOES_NOT_EXIST\",\n        requestId: \"DUMMY_REQUEST_ID\"\n      }));\n      middlewareWarning.triggered = true;\n      if (typeof registered !== \"boolean\") {\n        throw new Error(\"Warning: Middleware for RTK-Query API at reducerPath \\\"\" + api.reducerPath + \"\\\" has not been added to the store.\\nYou must add the middleware for RTK-Query to function correctly!\");\n      }\n    }\n  }\n  function buildInitiateQuery(endpointName, endpointDefinition) {\n    var queryAction = function (arg, _j) {\n      var _k = _j === void 0 ? {} : _j,\n        _l = _k.subscribe,\n        subscribe = _l === void 0 ? true : _l,\n        forceRefetch = _k.forceRefetch,\n        subscriptionOptions = _k.subscriptionOptions,\n        _m = forceQueryFnSymbol,\n        forceQueryFn = _k[_m];\n      return function (dispatch, getState) {\n        var _j;\n        var _a;\n        var queryCacheKey = serializeQueryArgs({\n          queryArgs: arg,\n          endpointDefinition: endpointDefinition,\n          endpointName: endpointName\n        });\n        var thunk = queryThunk((_j = {\n          type: \"query\",\n          subscribe: subscribe,\n          forceRefetch: forceRefetch,\n          subscriptionOptions: subscriptionOptions,\n          endpointName: endpointName,\n          originalArgs: arg,\n          queryCacheKey: queryCacheKey\n        }, _j[forceQueryFnSymbol] = forceQueryFn, _j));\n        var selector = api.endpoints[endpointName].select(arg);\n        var thunkResult = dispatch(thunk);\n        var stateAfter = selector(getState());\n        middlewareWarning(dispatch);\n        var requestId = thunkResult.requestId,\n          abort = thunkResult.abort;\n        var skippedSynchronously = stateAfter.requestId !== requestId;\n        var runningQuery = (_a = runningQueries.get(dispatch)) == null ? void 0 : _a[queryCacheKey];\n        var selectFromState = function () {\n          return selector(getState());\n        };\n        var statePromise = Object.assign(forceQueryFn ? thunkResult.then(selectFromState) : skippedSynchronously && !runningQuery ? Promise.resolve(stateAfter) : Promise.all([runningQuery, thunkResult]).then(selectFromState), {\n          arg: arg,\n          requestId: requestId,\n          subscriptionOptions: subscriptionOptions,\n          queryCacheKey: queryCacheKey,\n          abort: abort,\n          unwrap: function () {\n            return __async(this, null, function () {\n              var result;\n              return __generator(this, function (_j) {\n                switch (_j.label) {\n                  case 0:\n                    return [4 /*yield*/, statePromise];\n                  case 1:\n                    result = _j.sent();\n                    if (result.isError) {\n                      throw result.error;\n                    }\n                    return [2 /*return*/, result.data];\n                }\n              });\n            });\n          },\n          refetch: function () {\n            return dispatch(queryAction(arg, {\n              subscribe: false,\n              forceRefetch: true\n            }));\n          },\n          unsubscribe: function () {\n            if (subscribe) dispatch(unsubscribeQueryResult({\n              queryCacheKey: queryCacheKey,\n              requestId: requestId\n            }));\n          },\n          updateSubscriptionOptions: function (options) {\n            statePromise.subscriptionOptions = options;\n            dispatch(updateSubscriptionOptions({\n              endpointName: endpointName,\n              requestId: requestId,\n              queryCacheKey: queryCacheKey,\n              options: options\n            }));\n          }\n        });\n        if (!runningQuery && !skippedSynchronously && !forceQueryFn) {\n          var running_1 = runningQueries.get(dispatch) || {};\n          running_1[queryCacheKey] = statePromise;\n          runningQueries.set(dispatch, running_1);\n          statePromise.then(function () {\n            delete running_1[queryCacheKey];\n            if (!Object.keys(running_1).length) {\n              runningQueries.delete(dispatch);\n            }\n          });\n        }\n        return statePromise;\n      };\n    };\n    return queryAction;\n  }\n  function buildInitiateMutation(endpointName) {\n    return function (arg, _j) {\n      var _k = _j === void 0 ? {} : _j,\n        _l = _k.track,\n        track = _l === void 0 ? true : _l,\n        fixedCacheKey = _k.fixedCacheKey;\n      return function (dispatch, getState) {\n        var thunk = mutationThunk({\n          type: \"mutation\",\n          endpointName: endpointName,\n          originalArgs: arg,\n          track: track,\n          fixedCacheKey: fixedCacheKey\n        });\n        var thunkResult = dispatch(thunk);\n        middlewareWarning(dispatch);\n        var requestId = thunkResult.requestId,\n          abort = thunkResult.abort,\n          unwrap = thunkResult.unwrap;\n        var returnValuePromise = thunkResult.unwrap().then(function (data) {\n          return {\n            data: data\n          };\n        }).catch(function (error) {\n          return {\n            error: error\n          };\n        });\n        var reset = function () {\n          dispatch(removeMutationResult({\n            requestId: requestId,\n            fixedCacheKey: fixedCacheKey\n          }));\n        };\n        var ret = Object.assign(returnValuePromise, {\n          arg: thunkResult.arg,\n          requestId: requestId,\n          abort: abort,\n          unwrap: unwrap,\n          unsubscribe: reset,\n          reset: reset\n        });\n        var running = runningMutations.get(dispatch) || {};\n        runningMutations.set(dispatch, running);\n        running[requestId] = ret;\n        ret.then(function () {\n          delete running[requestId];\n          if (!Object.keys(running).length) {\n            runningMutations.delete(dispatch);\n          }\n        });\n        if (fixedCacheKey) {\n          running[fixedCacheKey] = ret;\n          ret.then(function () {\n            if (running[fixedCacheKey] === ret) {\n              delete running[fixedCacheKey];\n              if (!Object.keys(running).length) {\n                runningMutations.delete(dispatch);\n              }\n            }\n          });\n        }\n        return ret;\n      };\n    };\n  }\n}\n// src/query/core/buildThunks.ts\nimport { isAllOf, isFulfilled, isPending, isRejected, isRejectedWithValue } from \"@reduxjs/toolkit\";\nimport { isDraftable, produceWithPatches } from \"immer\";\nimport { createAsyncThunk, SHOULD_AUTOBATCH } from \"@reduxjs/toolkit\";\nfunction defaultTransformResponse(baseQueryReturnValue) {\n  return baseQueryReturnValue;\n}\nfunction buildThunks(_j) {\n  var _this = this;\n  var reducerPath = _j.reducerPath,\n    baseQuery = _j.baseQuery,\n    endpointDefinitions = _j.context.endpointDefinitions,\n    serializeQueryArgs = _j.serializeQueryArgs,\n    api = _j.api,\n    assertTagType = _j.assertTagType;\n  var patchQueryData = function (endpointName, args, patches, updateProvided) {\n    return function (dispatch, getState) {\n      var endpointDefinition = endpointDefinitions[endpointName];\n      var queryCacheKey = serializeQueryArgs({\n        queryArgs: args,\n        endpointDefinition: endpointDefinition,\n        endpointName: endpointName\n      });\n      dispatch(api.internalActions.queryResultPatched({\n        queryCacheKey: queryCacheKey,\n        patches: patches\n      }));\n      if (!updateProvided) {\n        return;\n      }\n      var newValue = api.endpoints[endpointName].select(args)(getState());\n      var providedTags = calculateProvidedBy(endpointDefinition.providesTags, newValue.data, void 0, args, {}, assertTagType);\n      dispatch(api.internalActions.updateProvidedBy({\n        queryCacheKey: queryCacheKey,\n        providedTags: providedTags\n      }));\n    };\n  };\n  var updateQueryData = function (endpointName, args, updateRecipe, updateProvided) {\n    if (updateProvided === void 0) {\n      updateProvided = true;\n    }\n    return function (dispatch, getState) {\n      var _j, _k;\n      var endpointDefinition = api.endpoints[endpointName];\n      var currentState = endpointDefinition.select(args)(getState());\n      var ret = {\n        patches: [],\n        inversePatches: [],\n        undo: function () {\n          return dispatch(api.util.patchQueryData(endpointName, args, ret.inversePatches, updateProvided));\n        }\n      };\n      if (currentState.status === QueryStatus.uninitialized) {\n        return ret;\n      }\n      var newValue;\n      if (\"data\" in currentState) {\n        if (isDraftable(currentState.data)) {\n          var _l = produceWithPatches(currentState.data, updateRecipe),\n            value = _l[0],\n            patches = _l[1],\n            inversePatches = _l[2];\n          (_j = ret.patches).push.apply(_j, patches);\n          (_k = ret.inversePatches).push.apply(_k, inversePatches);\n          newValue = value;\n        } else {\n          newValue = updateRecipe(currentState.data);\n          ret.patches.push({\n            op: \"replace\",\n            path: [],\n            value: newValue\n          });\n          ret.inversePatches.push({\n            op: \"replace\",\n            path: [],\n            value: currentState.data\n          });\n        }\n      }\n      dispatch(api.util.patchQueryData(endpointName, args, ret.patches, updateProvided));\n      return ret;\n    };\n  };\n  var upsertQueryData = function (endpointName, args, value) {\n    return function (dispatch) {\n      var _j;\n      return dispatch(api.endpoints[endpointName].initiate(args, (_j = {\n        subscribe: false,\n        forceRefetch: true\n      }, _j[forceQueryFnSymbol] = function () {\n        return {\n          data: value\n        };\n      }, _j)));\n    };\n  };\n  var executeEndpoint = function (_0, _1) {\n    return __async(_this, [_0, _1], function (arg, _j) {\n      var endpointDefinition, transformResponse, result, baseQueryApi_1, forceQueryFn, what, err, _k, _l, key, _m, error_1, catchedError, transformErrorResponse, _o, e_4;\n      var _p, _q;\n      var signal = _j.signal,\n        abort = _j.abort,\n        rejectWithValue = _j.rejectWithValue,\n        fulfillWithValue = _j.fulfillWithValue,\n        dispatch = _j.dispatch,\n        getState = _j.getState,\n        extra = _j.extra;\n      return __generator(this, function (_r) {\n        switch (_r.label) {\n          case 0:\n            endpointDefinition = endpointDefinitions[arg.endpointName];\n            _r.label = 1;\n          case 1:\n            _r.trys.push([1, 8,, 13]);\n            transformResponse = defaultTransformResponse;\n            result = void 0;\n            baseQueryApi_1 = {\n              signal: signal,\n              abort: abort,\n              dispatch: dispatch,\n              getState: getState,\n              extra: extra,\n              endpoint: arg.endpointName,\n              type: arg.type,\n              forced: arg.type === \"query\" ? isForcedQuery(arg, getState()) : void 0\n            };\n            forceQueryFn = arg.type === \"query\" ? arg[forceQueryFnSymbol] : void 0;\n            if (!forceQueryFn) return [3 /*break*/, 2];\n            result = forceQueryFn();\n            return [3 /*break*/, 6];\n          case 2:\n            if (!endpointDefinition.query) return [3 /*break*/, 4];\n            return [4 /*yield*/, baseQuery(endpointDefinition.query(arg.originalArgs), baseQueryApi_1, endpointDefinition.extraOptions)];\n          case 3:\n            result = _r.sent();\n            if (endpointDefinition.transformResponse) {\n              transformResponse = endpointDefinition.transformResponse;\n            }\n            return [3 /*break*/, 6];\n          case 4:\n            return [4 /*yield*/, endpointDefinition.queryFn(arg.originalArgs, baseQueryApi_1, endpointDefinition.extraOptions, function (arg2) {\n              return baseQuery(arg2, baseQueryApi_1, endpointDefinition.extraOptions);\n            })];\n          case 5:\n            result = _r.sent();\n            _r.label = 6;\n          case 6:\n            if (typeof process !== \"undefined\" && process.env.NODE_ENV === \"development\") {\n              what = endpointDefinition.query ? \"`baseQuery`\" : \"`queryFn`\";\n              err = void 0;\n              if (!result) {\n                err = what + \" did not return anything.\";\n              } else if (typeof result !== \"object\") {\n                err = what + \" did not return an object.\";\n              } else if (result.error && result.data) {\n                err = what + \" returned an object containing both `error` and `result`.\";\n              } else if (result.error === void 0 && result.data === void 0) {\n                err = what + \" returned an object containing neither a valid `error` and `result`. At least one of them should not be `undefined`\";\n              } else {\n                for (_k = 0, _l = Object.keys(result); _k < _l.length; _k++) {\n                  key = _l[_k];\n                  if (key !== \"error\" && key !== \"data\" && key !== \"meta\") {\n                    err = \"The object returned by \" + what + \" has the unknown property \" + key + \".\";\n                    break;\n                  }\n                }\n              }\n              if (err) {\n                console.error(\"Error encountered handling the endpoint \" + arg.endpointName + \".\\n              \" + err + \"\\n              It needs to return an object with either the shape `{ data: <value> }` or `{ error: <value> }` that may contain an optional `meta` property.\\n              Object returned was:\", result);\n              }\n            }\n            if (result.error) throw new HandledError(result.error, result.meta);\n            _m = fulfillWithValue;\n            return [4 /*yield*/, transformResponse(result.data, result.meta, arg.originalArgs)];\n          case 7:\n            return [2 /*return*/, _m.apply(void 0, [_r.sent(), (_p = {\n              fulfilledTimeStamp: Date.now(),\n              baseQueryMeta: result.meta\n            }, _p[SHOULD_AUTOBATCH] = true, _p)])];\n          case 8:\n            error_1 = _r.sent();\n            catchedError = error_1;\n            if (!(catchedError instanceof HandledError)) return [3 /*break*/, 12];\n            transformErrorResponse = defaultTransformResponse;\n            if (endpointDefinition.query && endpointDefinition.transformErrorResponse) {\n              transformErrorResponse = endpointDefinition.transformErrorResponse;\n            }\n            _r.label = 9;\n          case 9:\n            _r.trys.push([9, 11,, 12]);\n            _o = rejectWithValue;\n            return [4 /*yield*/, transformErrorResponse(catchedError.value, catchedError.meta, arg.originalArgs)];\n          case 10:\n            return [2 /*return*/, _o.apply(void 0, [_r.sent(), (_q = {\n              baseQueryMeta: catchedError.meta\n            }, _q[SHOULD_AUTOBATCH] = true, _q)])];\n          case 11:\n            e_4 = _r.sent();\n            catchedError = e_4;\n            return [3 /*break*/, 12];\n          case 12:\n            if (typeof process !== \"undefined\" && process.env.NODE_ENV !== \"production\") {\n              console.error(\"An unhandled error occurred processing a request for the endpoint \\\"\" + arg.endpointName + \"\\\".\\nIn the case of an unhandled error, no tags will be \\\"provided\\\" or \\\"invalidated\\\".\", catchedError);\n            } else {\n              console.error(catchedError);\n            }\n            throw catchedError;\n          case 13:\n            return [2 /*return*/];\n        }\n      });\n    });\n  };\n  function isForcedQuery(arg, state) {\n    var _a, _b, _c, _d;\n    var requestState = (_b = (_a = state[reducerPath]) == null ? void 0 : _a.queries) == null ? void 0 : _b[arg.queryCacheKey];\n    var baseFetchOnMountOrArgChange = (_c = state[reducerPath]) == null ? void 0 : _c.config.refetchOnMountOrArgChange;\n    var fulfilledVal = requestState == null ? void 0 : requestState.fulfilledTimeStamp;\n    var refetchVal = (_d = arg.forceRefetch) != null ? _d : arg.subscribe && baseFetchOnMountOrArgChange;\n    if (refetchVal) {\n      return refetchVal === true || (Number(new Date()) - Number(fulfilledVal)) / 1e3 >= refetchVal;\n    }\n    return false;\n  }\n  var queryThunk = createAsyncThunk(reducerPath + \"/executeQuery\", executeEndpoint, {\n    getPendingMeta: function () {\n      var _j;\n      return _j = {\n        startedTimeStamp: Date.now()\n      }, _j[SHOULD_AUTOBATCH] = true, _j;\n    },\n    condition: function (queryThunkArgs, _j) {\n      var getState = _j.getState;\n      var _a, _b, _c;\n      var state = getState();\n      var requestState = (_b = (_a = state[reducerPath]) == null ? void 0 : _a.queries) == null ? void 0 : _b[queryThunkArgs.queryCacheKey];\n      var fulfilledVal = requestState == null ? void 0 : requestState.fulfilledTimeStamp;\n      var currentArg = queryThunkArgs.originalArgs;\n      var previousArg = requestState == null ? void 0 : requestState.originalArgs;\n      var endpointDefinition = endpointDefinitions[queryThunkArgs.endpointName];\n      if (isUpsertQuery(queryThunkArgs)) {\n        return true;\n      }\n      if ((requestState == null ? void 0 : requestState.status) === \"pending\") {\n        return false;\n      }\n      if (isForcedQuery(queryThunkArgs, state)) {\n        return true;\n      }\n      if (isQueryDefinition(endpointDefinition) && ((_c = endpointDefinition == null ? void 0 : endpointDefinition.forceRefetch) == null ? void 0 : _c.call(endpointDefinition, {\n        currentArg: currentArg,\n        previousArg: previousArg,\n        endpointState: requestState,\n        state: state\n      }))) {\n        return true;\n      }\n      if (fulfilledVal) {\n        return false;\n      }\n      return true;\n    },\n    dispatchConditionRejection: true\n  });\n  var mutationThunk = createAsyncThunk(reducerPath + \"/executeMutation\", executeEndpoint, {\n    getPendingMeta: function () {\n      var _j;\n      return _j = {\n        startedTimeStamp: Date.now()\n      }, _j[SHOULD_AUTOBATCH] = true, _j;\n    }\n  });\n  var hasTheForce = function (options) {\n    return \"force\" in options;\n  };\n  var hasMaxAge = function (options) {\n    return \"ifOlderThan\" in options;\n  };\n  var prefetch = function (endpointName, arg, options) {\n    return function (dispatch, getState) {\n      var force = hasTheForce(options) && options.force;\n      var maxAge = hasMaxAge(options) && options.ifOlderThan;\n      var queryAction = function (force2) {\n        if (force2 === void 0) {\n          force2 = true;\n        }\n        return api.endpoints[endpointName].initiate(arg, {\n          forceRefetch: force2\n        });\n      };\n      var latestStateValue = api.endpoints[endpointName].select(arg)(getState());\n      if (force) {\n        dispatch(queryAction());\n      } else if (maxAge) {\n        var lastFulfilledTs = latestStateValue == null ? void 0 : latestStateValue.fulfilledTimeStamp;\n        if (!lastFulfilledTs) {\n          dispatch(queryAction());\n          return;\n        }\n        var shouldRetrigger = (Number(new Date()) - Number(new Date(lastFulfilledTs))) / 1e3 >= maxAge;\n        if (shouldRetrigger) {\n          dispatch(queryAction());\n        }\n      } else {\n        dispatch(queryAction(false));\n      }\n    };\n  };\n  function matchesEndpoint(endpointName) {\n    return function (action) {\n      var _a, _b;\n      return ((_b = (_a = action == null ? void 0 : action.meta) == null ? void 0 : _a.arg) == null ? void 0 : _b.endpointName) === endpointName;\n    };\n  }\n  function buildMatchThunkActions(thunk, endpointName) {\n    return {\n      matchPending: isAllOf(isPending(thunk), matchesEndpoint(endpointName)),\n      matchFulfilled: isAllOf(isFulfilled(thunk), matchesEndpoint(endpointName)),\n      matchRejected: isAllOf(isRejected(thunk), matchesEndpoint(endpointName))\n    };\n  }\n  return {\n    queryThunk: queryThunk,\n    mutationThunk: mutationThunk,\n    prefetch: prefetch,\n    updateQueryData: updateQueryData,\n    upsertQueryData: upsertQueryData,\n    patchQueryData: patchQueryData,\n    buildMatchThunkActions: buildMatchThunkActions\n  };\n}\nfunction calculateProvidedByThunk(action, type, endpointDefinitions, assertTagType) {\n  return calculateProvidedBy(endpointDefinitions[action.meta.arg.endpointName][type], isFulfilled(action) ? action.payload : void 0, isRejectedWithValue(action) ? action.payload : void 0, action.meta.arg.originalArgs, \"baseQueryMeta\" in action.meta ? action.meta.baseQueryMeta : void 0, assertTagType);\n}\n// src/query/core/buildSlice.ts\nimport { isDraft } from \"immer\";\nimport { applyPatches, original } from \"immer\";\nfunction updateQuerySubstateIfExists(state, queryCacheKey, update) {\n  var substate = state[queryCacheKey];\n  if (substate) {\n    update(substate);\n  }\n}\nfunction getMutationCacheKey(id) {\n  var _a;\n  return (_a = \"arg\" in id ? id.arg.fixedCacheKey : id.fixedCacheKey) != null ? _a : id.requestId;\n}\nfunction updateMutationSubstateIfExists(state, id, update) {\n  var substate = state[getMutationCacheKey(id)];\n  if (substate) {\n    update(substate);\n  }\n}\nvar initialState = {};\nfunction buildSlice(_j) {\n  var reducerPath = _j.reducerPath,\n    queryThunk = _j.queryThunk,\n    mutationThunk = _j.mutationThunk,\n    _k = _j.context,\n    definitions = _k.endpointDefinitions,\n    apiUid = _k.apiUid,\n    extractRehydrationInfo = _k.extractRehydrationInfo,\n    hasRehydrationInfo = _k.hasRehydrationInfo,\n    assertTagType = _j.assertTagType,\n    config = _j.config;\n  var resetApiState = createAction2(reducerPath + \"/resetApiState\");\n  var querySlice = createSlice({\n    name: reducerPath + \"/queries\",\n    initialState: initialState,\n    reducers: {\n      removeQueryResult: {\n        reducer: function (draft, _j) {\n          var queryCacheKey = _j.payload.queryCacheKey;\n          delete draft[queryCacheKey];\n        },\n        prepare: prepareAutoBatched()\n      },\n      queryResultPatched: {\n        reducer: function (draft, _j) {\n          var _k = _j.payload,\n            queryCacheKey = _k.queryCacheKey,\n            patches = _k.patches;\n          updateQuerySubstateIfExists(draft, queryCacheKey, function (substate) {\n            substate.data = applyPatches(substate.data, patches.concat());\n          });\n        },\n        prepare: prepareAutoBatched()\n      }\n    },\n    extraReducers: function (builder) {\n      builder.addCase(queryThunk.pending, function (draft, _j) {\n        var meta = _j.meta,\n          arg = _j.meta.arg;\n        var _a, _b;\n        var upserting = isUpsertQuery(arg);\n        if (arg.subscribe || upserting) {\n          (_b = draft[_a = arg.queryCacheKey]) != null ? _b : draft[_a] = {\n            status: QueryStatus.uninitialized,\n            endpointName: arg.endpointName\n          };\n        }\n        updateQuerySubstateIfExists(draft, arg.queryCacheKey, function (substate) {\n          substate.status = QueryStatus.pending;\n          substate.requestId = upserting && substate.requestId ? substate.requestId : meta.requestId;\n          if (arg.originalArgs !== void 0) {\n            substate.originalArgs = arg.originalArgs;\n          }\n          substate.startedTimeStamp = meta.startedTimeStamp;\n        });\n      }).addCase(queryThunk.fulfilled, function (draft, _j) {\n        var meta = _j.meta,\n          payload = _j.payload;\n        updateQuerySubstateIfExists(draft, meta.arg.queryCacheKey, function (substate) {\n          var _a;\n          if (substate.requestId !== meta.requestId && !isUpsertQuery(meta.arg)) return;\n          var merge = definitions[meta.arg.endpointName].merge;\n          substate.status = QueryStatus.fulfilled;\n          if (merge) {\n            if (substate.data !== void 0) {\n              var fulfilledTimeStamp_1 = meta.fulfilledTimeStamp,\n                arg_1 = meta.arg,\n                baseQueryMeta_1 = meta.baseQueryMeta,\n                requestId_1 = meta.requestId;\n              var newData = createNextState(substate.data, function (draftSubstateData) {\n                return merge(draftSubstateData, payload, {\n                  arg: arg_1.originalArgs,\n                  baseQueryMeta: baseQueryMeta_1,\n                  fulfilledTimeStamp: fulfilledTimeStamp_1,\n                  requestId: requestId_1\n                });\n              });\n              substate.data = newData;\n            } else {\n              substate.data = payload;\n            }\n          } else {\n            substate.data = ((_a = definitions[meta.arg.endpointName].structuralSharing) != null ? _a : true) ? copyWithStructuralSharing(isDraft(substate.data) ? original(substate.data) : substate.data, payload) : payload;\n          }\n          delete substate.error;\n          substate.fulfilledTimeStamp = meta.fulfilledTimeStamp;\n        });\n      }).addCase(queryThunk.rejected, function (draft, _j) {\n        var _k = _j.meta,\n          condition = _k.condition,\n          arg = _k.arg,\n          requestId = _k.requestId,\n          error = _j.error,\n          payload = _j.payload;\n        updateQuerySubstateIfExists(draft, arg.queryCacheKey, function (substate) {\n          if (condition) {} else {\n            if (substate.requestId !== requestId) return;\n            substate.status = QueryStatus.rejected;\n            substate.error = payload != null ? payload : error;\n          }\n        });\n      }).addMatcher(hasRehydrationInfo, function (draft, action) {\n        var queries = extractRehydrationInfo(action).queries;\n        for (var _j = 0, _k = Object.entries(queries); _j < _k.length; _j++) {\n          var _l = _k[_j],\n            key = _l[0],\n            entry = _l[1];\n          if ((entry == null ? void 0 : entry.status) === QueryStatus.fulfilled || (entry == null ? void 0 : entry.status) === QueryStatus.rejected) {\n            draft[key] = entry;\n          }\n        }\n      });\n    }\n  });\n  var mutationSlice = createSlice({\n    name: reducerPath + \"/mutations\",\n    initialState: initialState,\n    reducers: {\n      removeMutationResult: {\n        reducer: function (draft, _j) {\n          var payload = _j.payload;\n          var cacheKey = getMutationCacheKey(payload);\n          if (cacheKey in draft) {\n            delete draft[cacheKey];\n          }\n        },\n        prepare: prepareAutoBatched()\n      }\n    },\n    extraReducers: function (builder) {\n      builder.addCase(mutationThunk.pending, function (draft, _j) {\n        var meta = _j.meta,\n          _k = _j.meta,\n          requestId = _k.requestId,\n          arg = _k.arg,\n          startedTimeStamp = _k.startedTimeStamp;\n        if (!arg.track) return;\n        draft[getMutationCacheKey(meta)] = {\n          requestId: requestId,\n          status: QueryStatus.pending,\n          endpointName: arg.endpointName,\n          startedTimeStamp: startedTimeStamp\n        };\n      }).addCase(mutationThunk.fulfilled, function (draft, _j) {\n        var payload = _j.payload,\n          meta = _j.meta;\n        if (!meta.arg.track) return;\n        updateMutationSubstateIfExists(draft, meta, function (substate) {\n          if (substate.requestId !== meta.requestId) return;\n          substate.status = QueryStatus.fulfilled;\n          substate.data = payload;\n          substate.fulfilledTimeStamp = meta.fulfilledTimeStamp;\n        });\n      }).addCase(mutationThunk.rejected, function (draft, _j) {\n        var payload = _j.payload,\n          error = _j.error,\n          meta = _j.meta;\n        if (!meta.arg.track) return;\n        updateMutationSubstateIfExists(draft, meta, function (substate) {\n          if (substate.requestId !== meta.requestId) return;\n          substate.status = QueryStatus.rejected;\n          substate.error = payload != null ? payload : error;\n        });\n      }).addMatcher(hasRehydrationInfo, function (draft, action) {\n        var mutations = extractRehydrationInfo(action).mutations;\n        for (var _j = 0, _k = Object.entries(mutations); _j < _k.length; _j++) {\n          var _l = _k[_j],\n            key = _l[0],\n            entry = _l[1];\n          if (((entry == null ? void 0 : entry.status) === QueryStatus.fulfilled || (entry == null ? void 0 : entry.status) === QueryStatus.rejected) && key !== (entry == null ? void 0 : entry.requestId)) {\n            draft[key] = entry;\n          }\n        }\n      });\n    }\n  });\n  var invalidationSlice = createSlice({\n    name: reducerPath + \"/invalidation\",\n    initialState: initialState,\n    reducers: {\n      updateProvidedBy: {\n        reducer: function (draft, action) {\n          var _a, _b, _c, _d;\n          var _j = action.payload,\n            queryCacheKey = _j.queryCacheKey,\n            providedTags = _j.providedTags;\n          for (var _k = 0, _l = Object.values(draft); _k < _l.length; _k++) {\n            var tagTypeSubscriptions = _l[_k];\n            for (var _m = 0, _o = Object.values(tagTypeSubscriptions); _m < _o.length; _m++) {\n              var idSubscriptions = _o[_m];\n              var foundAt = idSubscriptions.indexOf(queryCacheKey);\n              if (foundAt !== -1) {\n                idSubscriptions.splice(foundAt, 1);\n              }\n            }\n          }\n          for (var _p = 0, providedTags_1 = providedTags; _p < providedTags_1.length; _p++) {\n            var _q = providedTags_1[_p],\n              type = _q.type,\n              id = _q.id;\n            var subscribedQueries = (_d = (_b = (_a = draft[type]) != null ? _a : draft[type] = {})[_c = id || \"__internal_without_id\"]) != null ? _d : _b[_c] = [];\n            var alreadySubscribed = subscribedQueries.includes(queryCacheKey);\n            if (!alreadySubscribed) {\n              subscribedQueries.push(queryCacheKey);\n            }\n          }\n        },\n        prepare: prepareAutoBatched()\n      }\n    },\n    extraReducers: function (builder) {\n      builder.addCase(querySlice.actions.removeQueryResult, function (draft, _j) {\n        var queryCacheKey = _j.payload.queryCacheKey;\n        for (var _k = 0, _l = Object.values(draft); _k < _l.length; _k++) {\n          var tagTypeSubscriptions = _l[_k];\n          for (var _m = 0, _o = Object.values(tagTypeSubscriptions); _m < _o.length; _m++) {\n            var idSubscriptions = _o[_m];\n            var foundAt = idSubscriptions.indexOf(queryCacheKey);\n            if (foundAt !== -1) {\n              idSubscriptions.splice(foundAt, 1);\n            }\n          }\n        }\n      }).addMatcher(hasRehydrationInfo, function (draft, action) {\n        var _a, _b, _c, _d;\n        var provided = extractRehydrationInfo(action).provided;\n        for (var _j = 0, _k = Object.entries(provided); _j < _k.length; _j++) {\n          var _l = _k[_j],\n            type = _l[0],\n            incomingTags = _l[1];\n          for (var _m = 0, _o = Object.entries(incomingTags); _m < _o.length; _m++) {\n            var _p = _o[_m],\n              id = _p[0],\n              cacheKeys = _p[1];\n            var subscribedQueries = (_d = (_b = (_a = draft[type]) != null ? _a : draft[type] = {})[_c = id || \"__internal_without_id\"]) != null ? _d : _b[_c] = [];\n            for (var _q = 0, cacheKeys_1 = cacheKeys; _q < cacheKeys_1.length; _q++) {\n              var queryCacheKey = cacheKeys_1[_q];\n              var alreadySubscribed = subscribedQueries.includes(queryCacheKey);\n              if (!alreadySubscribed) {\n                subscribedQueries.push(queryCacheKey);\n              }\n            }\n          }\n        }\n      }).addMatcher(isAnyOf(isFulfilled2(queryThunk), isRejectedWithValue2(queryThunk)), function (draft, action) {\n        var providedTags = calculateProvidedByThunk(action, \"providesTags\", definitions, assertTagType);\n        var queryCacheKey = action.meta.arg.queryCacheKey;\n        invalidationSlice.caseReducers.updateProvidedBy(draft, invalidationSlice.actions.updateProvidedBy({\n          queryCacheKey: queryCacheKey,\n          providedTags: providedTags\n        }));\n      });\n    }\n  });\n  var subscriptionSlice = createSlice({\n    name: reducerPath + \"/subscriptions\",\n    initialState: initialState,\n    reducers: {\n      updateSubscriptionOptions: function (d, a) {},\n      unsubscribeQueryResult: function (d, a) {},\n      internal_probeSubscription: function (d, a) {}\n    }\n  });\n  var internalSubscriptionsSlice = createSlice({\n    name: reducerPath + \"/internalSubscriptions\",\n    initialState: initialState,\n    reducers: {\n      subscriptionsUpdated: {\n        reducer: function (state, action) {\n          return applyPatches(state, action.payload);\n        },\n        prepare: prepareAutoBatched()\n      }\n    }\n  });\n  var configSlice = createSlice({\n    name: reducerPath + \"/config\",\n    initialState: __spreadValues({\n      online: isOnline(),\n      focused: isDocumentVisible(),\n      middlewareRegistered: false\n    }, config),\n    reducers: {\n      middlewareRegistered: function (state, _j) {\n        var payload = _j.payload;\n        state.middlewareRegistered = state.middlewareRegistered === \"conflict\" || apiUid !== payload ? \"conflict\" : true;\n      }\n    },\n    extraReducers: function (builder) {\n      builder.addCase(onOnline, function (state) {\n        state.online = true;\n      }).addCase(onOffline, function (state) {\n        state.online = false;\n      }).addCase(onFocus, function (state) {\n        state.focused = true;\n      }).addCase(onFocusLost, function (state) {\n        state.focused = false;\n      }).addMatcher(hasRehydrationInfo, function (draft) {\n        return __spreadValues({}, draft);\n      });\n    }\n  });\n  var combinedReducer = combineReducers({\n    queries: querySlice.reducer,\n    mutations: mutationSlice.reducer,\n    provided: invalidationSlice.reducer,\n    subscriptions: internalSubscriptionsSlice.reducer,\n    config: configSlice.reducer\n  });\n  var reducer = function (state, action) {\n    return combinedReducer(resetApiState.match(action) ? void 0 : state, action);\n  };\n  var actions = __spreadProps(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues({}, configSlice.actions), querySlice.actions), subscriptionSlice.actions), internalSubscriptionsSlice.actions), mutationSlice.actions), invalidationSlice.actions), {\n    unsubscribeMutationResult: mutationSlice.actions.removeMutationResult,\n    resetApiState: resetApiState\n  });\n  return {\n    reducer: reducer,\n    actions: actions\n  };\n}\n// src/query/core/buildSelectors.ts\nvar skipToken = /* @__PURE__ */Symbol.for(\"RTKQ/skipToken\");\nvar skipSelector = skipToken;\nvar initialSubState = {\n  status: QueryStatus.uninitialized\n};\nvar defaultQuerySubState = /* @__PURE__ */createNextState2(initialSubState, function () {});\nvar defaultMutationSubState = /* @__PURE__ */createNextState2(initialSubState, function () {});\nfunction buildSelectors(_j) {\n  var serializeQueryArgs = _j.serializeQueryArgs,\n    reducerPath = _j.reducerPath;\n  var selectSkippedQuery = function (state) {\n    return defaultQuerySubState;\n  };\n  var selectSkippedMutation = function (state) {\n    return defaultMutationSubState;\n  };\n  return {\n    buildQuerySelector: buildQuerySelector,\n    buildMutationSelector: buildMutationSelector,\n    selectInvalidatedBy: selectInvalidatedBy\n  };\n  function withRequestFlags(substate) {\n    return __spreadValues(__spreadValues({}, substate), getRequestStatusFlags(substate.status));\n  }\n  function selectInternalState(rootState) {\n    var state = rootState[reducerPath];\n    if (process.env.NODE_ENV !== \"production\") {\n      if (!state) {\n        if (selectInternalState.triggered) return state;\n        selectInternalState.triggered = true;\n        console.error(\"Error: No data found at `state.\" + reducerPath + \"`. Did you forget to add the reducer to the store?\");\n      }\n    }\n    return state;\n  }\n  function buildQuerySelector(endpointName, endpointDefinition) {\n    return function (queryArgs) {\n      var serializedArgs = serializeQueryArgs({\n        queryArgs: queryArgs,\n        endpointDefinition: endpointDefinition,\n        endpointName: endpointName\n      });\n      var selectQuerySubstate = function (state) {\n        var _a, _b, _c;\n        return (_c = (_b = (_a = selectInternalState(state)) == null ? void 0 : _a.queries) == null ? void 0 : _b[serializedArgs]) != null ? _c : defaultQuerySubState;\n      };\n      var finalSelectQuerySubState = queryArgs === skipToken ? selectSkippedQuery : selectQuerySubstate;\n      return createSelector(finalSelectQuerySubState, withRequestFlags);\n    };\n  }\n  function buildMutationSelector() {\n    return function (id) {\n      var _a;\n      var mutationId;\n      if (typeof id === \"object\") {\n        mutationId = (_a = getMutationCacheKey(id)) != null ? _a : skipToken;\n      } else {\n        mutationId = id;\n      }\n      var selectMutationSubstate = function (state) {\n        var _a2, _b, _c;\n        return (_c = (_b = (_a2 = selectInternalState(state)) == null ? void 0 : _a2.mutations) == null ? void 0 : _b[mutationId]) != null ? _c : defaultMutationSubState;\n      };\n      var finalSelectMutationSubstate = mutationId === skipToken ? selectSkippedMutation : selectMutationSubstate;\n      return createSelector(finalSelectMutationSubstate, withRequestFlags);\n    };\n  }\n  function selectInvalidatedBy(state, tags) {\n    var _a;\n    var apiState = state[reducerPath];\n    var toInvalidate = new Set();\n    for (var _j = 0, _k = tags.map(expandTagDescription); _j < _k.length; _j++) {\n      var tag = _k[_j];\n      var provided = apiState.provided[tag.type];\n      if (!provided) {\n        continue;\n      }\n      var invalidateSubscriptions = (_a = tag.id !== void 0 ? provided[tag.id] : flatten(Object.values(provided))) != null ? _a : [];\n      for (var _l = 0, invalidateSubscriptions_1 = invalidateSubscriptions; _l < invalidateSubscriptions_1.length; _l++) {\n        var invalidate = invalidateSubscriptions_1[_l];\n        toInvalidate.add(invalidate);\n      }\n    }\n    return flatten(Array.from(toInvalidate.values()).map(function (queryCacheKey) {\n      var querySubState = apiState.queries[queryCacheKey];\n      return querySubState ? [{\n        queryCacheKey: queryCacheKey,\n        endpointName: querySubState.endpointName,\n        originalArgs: querySubState.originalArgs\n      }] : [];\n    }));\n  }\n}\n// src/query/defaultSerializeQueryArgs.ts\nimport { isPlainObject as isPlainObject3 } from \"@reduxjs/toolkit\";\nvar cache = WeakMap ? new WeakMap() : void 0;\nvar defaultSerializeQueryArgs = function (_j) {\n  var endpointName = _j.endpointName,\n    queryArgs = _j.queryArgs;\n  var serialized = \"\";\n  var cached = cache == null ? void 0 : cache.get(queryArgs);\n  if (typeof cached === \"string\") {\n    serialized = cached;\n  } else {\n    var stringified = JSON.stringify(queryArgs, function (key, value) {\n      return isPlainObject3(value) ? Object.keys(value).sort().reduce(function (acc, key2) {\n        acc[key2] = value[key2];\n        return acc;\n      }, {}) : value;\n    });\n    if (isPlainObject3(queryArgs)) {\n      cache == null ? void 0 : cache.set(queryArgs, stringified);\n    }\n    serialized = stringified;\n  }\n  return endpointName + \"(\" + serialized + \")\";\n};\n// src/query/createApi.ts\nimport { nanoid } from \"@reduxjs/toolkit\";\nimport { defaultMemoize } from \"reselect\";\nfunction buildCreateApi() {\n  var modules = [];\n  for (var _j = 0; _j < arguments.length; _j++) {\n    modules[_j] = arguments[_j];\n  }\n  return function baseCreateApi(options) {\n    var extractRehydrationInfo = defaultMemoize(function (action) {\n      var _a, _b;\n      return (_b = options.extractRehydrationInfo) == null ? void 0 : _b.call(options, action, {\n        reducerPath: (_a = options.reducerPath) != null ? _a : \"api\"\n      });\n    });\n    var optionsWithDefaults = __spreadProps(__spreadValues({\n      reducerPath: \"api\",\n      keepUnusedDataFor: 60,\n      refetchOnMountOrArgChange: false,\n      refetchOnFocus: false,\n      refetchOnReconnect: false\n    }, options), {\n      extractRehydrationInfo: extractRehydrationInfo,\n      serializeQueryArgs: function (queryArgsApi) {\n        var finalSerializeQueryArgs = defaultSerializeQueryArgs;\n        if (\"serializeQueryArgs\" in queryArgsApi.endpointDefinition) {\n          var endpointSQA_1 = queryArgsApi.endpointDefinition.serializeQueryArgs;\n          finalSerializeQueryArgs = function (queryArgsApi2) {\n            var initialResult = endpointSQA_1(queryArgsApi2);\n            if (typeof initialResult === \"string\") {\n              return initialResult;\n            } else {\n              return defaultSerializeQueryArgs(__spreadProps(__spreadValues({}, queryArgsApi2), {\n                queryArgs: initialResult\n              }));\n            }\n          };\n        } else if (options.serializeQueryArgs) {\n          finalSerializeQueryArgs = options.serializeQueryArgs;\n        }\n        return finalSerializeQueryArgs(queryArgsApi);\n      },\n      tagTypes: __spreadArray([], options.tagTypes || [])\n    });\n    var context = {\n      endpointDefinitions: {},\n      batch: function (fn) {\n        fn();\n      },\n      apiUid: nanoid(),\n      extractRehydrationInfo: extractRehydrationInfo,\n      hasRehydrationInfo: defaultMemoize(function (action) {\n        return extractRehydrationInfo(action) != null;\n      })\n    };\n    var api = {\n      injectEndpoints: injectEndpoints,\n      enhanceEndpoints: function (_j) {\n        var addTagTypes = _j.addTagTypes,\n          endpoints = _j.endpoints;\n        if (addTagTypes) {\n          for (var _k = 0, addTagTypes_1 = addTagTypes; _k < addTagTypes_1.length; _k++) {\n            var eT = addTagTypes_1[_k];\n            if (!optionsWithDefaults.tagTypes.includes(eT)) {\n              ;\n              optionsWithDefaults.tagTypes.push(eT);\n            }\n          }\n        }\n        if (endpoints) {\n          for (var _l = 0, _m = Object.entries(endpoints); _l < _m.length; _l++) {\n            var _o = _m[_l],\n              endpointName = _o[0],\n              partialDefinition = _o[1];\n            if (typeof partialDefinition === \"function\") {\n              partialDefinition(context.endpointDefinitions[endpointName]);\n            } else {\n              Object.assign(context.endpointDefinitions[endpointName] || {}, partialDefinition);\n            }\n          }\n        }\n        return api;\n      }\n    };\n    var initializedModules = modules.map(function (m) {\n      return m.init(api, optionsWithDefaults, context);\n    });\n    function injectEndpoints(inject) {\n      var evaluatedEndpoints = inject.endpoints({\n        query: function (x) {\n          return __spreadProps(__spreadValues({}, x), {\n            type: DefinitionType.query\n          });\n        },\n        mutation: function (x) {\n          return __spreadProps(__spreadValues({}, x), {\n            type: DefinitionType.mutation\n          });\n        }\n      });\n      for (var _j = 0, _k = Object.entries(evaluatedEndpoints); _j < _k.length; _j++) {\n        var _l = _k[_j],\n          endpointName = _l[0],\n          definition = _l[1];\n        if (!inject.overrideExisting && endpointName in context.endpointDefinitions) {\n          if (typeof process !== \"undefined\" && process.env.NODE_ENV === \"development\") {\n            console.error(\"called `injectEndpoints` to override already-existing endpointName \" + endpointName + \" without specifying `overrideExisting: true`\");\n          }\n          continue;\n        }\n        context.endpointDefinitions[endpointName] = definition;\n        for (var _m = 0, initializedModules_1 = initializedModules; _m < initializedModules_1.length; _m++) {\n          var m = initializedModules_1[_m];\n          m.injectEndpoint(endpointName, definition);\n        }\n      }\n      return api;\n    }\n    return api.injectEndpoints({\n      endpoints: options.endpoints\n    });\n  };\n}\n// src/query/fakeBaseQuery.ts\nfunction fakeBaseQuery() {\n  return function () {\n    throw new Error(\"When using `fakeBaseQuery`, all queries & mutations must use the `queryFn` definition syntax.\");\n  };\n}\n// src/query/core/buildMiddleware/index.ts\nimport { createAction as createAction3 } from \"@reduxjs/toolkit\";\n// src/query/core/buildMiddleware/cacheCollection.ts\nfunction isObjectEmpty(obj) {\n  for (var k in obj) {\n    return false;\n  }\n  return true;\n}\nvar THIRTY_TWO_BIT_MAX_TIMER_SECONDS = 2147483647 / 1e3 - 1;\nvar buildCacheCollectionHandler = function (_j) {\n  var reducerPath = _j.reducerPath,\n    api = _j.api,\n    context = _j.context,\n    internalState = _j.internalState;\n  var _k = api.internalActions,\n    removeQueryResult = _k.removeQueryResult,\n    unsubscribeQueryResult = _k.unsubscribeQueryResult;\n  function anySubscriptionsRemainingForKey(queryCacheKey) {\n    var subscriptions = internalState.currentSubscriptions[queryCacheKey];\n    return !!subscriptions && !isObjectEmpty(subscriptions);\n  }\n  var currentRemovalTimeouts = {};\n  var handler = function (action, mwApi, internalState2) {\n    var _a;\n    if (unsubscribeQueryResult.match(action)) {\n      var state = mwApi.getState()[reducerPath];\n      var queryCacheKey = action.payload.queryCacheKey;\n      handleUnsubscribe(queryCacheKey, (_a = state.queries[queryCacheKey]) == null ? void 0 : _a.endpointName, mwApi, state.config);\n    }\n    if (api.util.resetApiState.match(action)) {\n      for (var _j = 0, _k = Object.entries(currentRemovalTimeouts); _j < _k.length; _j++) {\n        var _l = _k[_j],\n          key = _l[0],\n          timeout = _l[1];\n        if (timeout) clearTimeout(timeout);\n        delete currentRemovalTimeouts[key];\n      }\n    }\n    if (context.hasRehydrationInfo(action)) {\n      var state = mwApi.getState()[reducerPath];\n      var queries = context.extractRehydrationInfo(action).queries;\n      for (var _m = 0, _o = Object.entries(queries); _m < _o.length; _m++) {\n        var _p = _o[_m],\n          queryCacheKey = _p[0],\n          queryState = _p[1];\n        handleUnsubscribe(queryCacheKey, queryState == null ? void 0 : queryState.endpointName, mwApi, state.config);\n      }\n    }\n  };\n  function handleUnsubscribe(queryCacheKey, endpointName, api2, config) {\n    var _a;\n    var endpointDefinition = context.endpointDefinitions[endpointName];\n    var keepUnusedDataFor = (_a = endpointDefinition == null ? void 0 : endpointDefinition.keepUnusedDataFor) != null ? _a : config.keepUnusedDataFor;\n    if (keepUnusedDataFor === Infinity) {\n      return;\n    }\n    var finalKeepUnusedDataFor = Math.max(0, Math.min(keepUnusedDataFor, THIRTY_TWO_BIT_MAX_TIMER_SECONDS));\n    if (!anySubscriptionsRemainingForKey(queryCacheKey)) {\n      var currentTimeout = currentRemovalTimeouts[queryCacheKey];\n      if (currentTimeout) {\n        clearTimeout(currentTimeout);\n      }\n      currentRemovalTimeouts[queryCacheKey] = setTimeout(function () {\n        if (!anySubscriptionsRemainingForKey(queryCacheKey)) {\n          api2.dispatch(removeQueryResult({\n            queryCacheKey: queryCacheKey\n          }));\n        }\n        delete currentRemovalTimeouts[queryCacheKey];\n      }, finalKeepUnusedDataFor * 1e3);\n    }\n  }\n  return handler;\n};\n// src/query/core/buildMiddleware/invalidationByTags.ts\nimport { isAnyOf as isAnyOf2, isFulfilled as isFulfilled3, isRejectedWithValue as isRejectedWithValue3 } from \"@reduxjs/toolkit\";\nvar buildInvalidationByTagsHandler = function (_j) {\n  var reducerPath = _j.reducerPath,\n    context = _j.context,\n    endpointDefinitions = _j.context.endpointDefinitions,\n    mutationThunk = _j.mutationThunk,\n    api = _j.api,\n    assertTagType = _j.assertTagType,\n    refetchQuery = _j.refetchQuery;\n  var removeQueryResult = api.internalActions.removeQueryResult;\n  var isThunkActionWithTags = isAnyOf2(isFulfilled3(mutationThunk), isRejectedWithValue3(mutationThunk));\n  var handler = function (action, mwApi) {\n    if (isThunkActionWithTags(action)) {\n      invalidateTags(calculateProvidedByThunk(action, \"invalidatesTags\", endpointDefinitions, assertTagType), mwApi);\n    }\n    if (api.util.invalidateTags.match(action)) {\n      invalidateTags(calculateProvidedBy(action.payload, void 0, void 0, void 0, void 0, assertTagType), mwApi);\n    }\n  };\n  function invalidateTags(tags, mwApi) {\n    var rootState = mwApi.getState();\n    var state = rootState[reducerPath];\n    var toInvalidate = api.util.selectInvalidatedBy(rootState, tags);\n    context.batch(function () {\n      var _a;\n      var valuesArray = Array.from(toInvalidate.values());\n      for (var _j = 0, valuesArray_1 = valuesArray; _j < valuesArray_1.length; _j++) {\n        var queryCacheKey = valuesArray_1[_j].queryCacheKey;\n        var querySubState = state.queries[queryCacheKey];\n        var subscriptionSubState = (_a = state.subscriptions[queryCacheKey]) != null ? _a : {};\n        if (querySubState) {\n          if (Object.keys(subscriptionSubState).length === 0) {\n            mwApi.dispatch(removeQueryResult({\n              queryCacheKey: queryCacheKey\n            }));\n          } else if (querySubState.status !== QueryStatus.uninitialized) {\n            mwApi.dispatch(refetchQuery(querySubState, queryCacheKey));\n          }\n        }\n      }\n    });\n  }\n  return handler;\n};\n// src/query/core/buildMiddleware/polling.ts\nvar buildPollingHandler = function (_j) {\n  var reducerPath = _j.reducerPath,\n    queryThunk = _j.queryThunk,\n    api = _j.api,\n    refetchQuery = _j.refetchQuery,\n    internalState = _j.internalState;\n  var currentPolls = {};\n  var handler = function (action, mwApi) {\n    if (api.internalActions.updateSubscriptionOptions.match(action) || api.internalActions.unsubscribeQueryResult.match(action)) {\n      updatePollingInterval(action.payload, mwApi);\n    }\n    if (queryThunk.pending.match(action) || queryThunk.rejected.match(action) && action.meta.condition) {\n      updatePollingInterval(action.meta.arg, mwApi);\n    }\n    if (queryThunk.fulfilled.match(action) || queryThunk.rejected.match(action) && !action.meta.condition) {\n      startNextPoll(action.meta.arg, mwApi);\n    }\n    if (api.util.resetApiState.match(action)) {\n      clearPolls();\n    }\n  };\n  function startNextPoll(_j, api2) {\n    var queryCacheKey = _j.queryCacheKey;\n    var state = api2.getState()[reducerPath];\n    var querySubState = state.queries[queryCacheKey];\n    var subscriptions = internalState.currentSubscriptions[queryCacheKey];\n    if (!querySubState || querySubState.status === QueryStatus.uninitialized) return;\n    var lowestPollingInterval = findLowestPollingInterval(subscriptions);\n    if (!Number.isFinite(lowestPollingInterval)) return;\n    var currentPoll = currentPolls[queryCacheKey];\n    if (currentPoll == null ? void 0 : currentPoll.timeout) {\n      clearTimeout(currentPoll.timeout);\n      currentPoll.timeout = void 0;\n    }\n    var nextPollTimestamp = Date.now() + lowestPollingInterval;\n    var currentInterval = currentPolls[queryCacheKey] = {\n      nextPollTimestamp: nextPollTimestamp,\n      pollingInterval: lowestPollingInterval,\n      timeout: setTimeout(function () {\n        currentInterval.timeout = void 0;\n        api2.dispatch(refetchQuery(querySubState, queryCacheKey));\n      }, lowestPollingInterval)\n    };\n  }\n  function updatePollingInterval(_j, api2) {\n    var queryCacheKey = _j.queryCacheKey;\n    var state = api2.getState()[reducerPath];\n    var querySubState = state.queries[queryCacheKey];\n    var subscriptions = internalState.currentSubscriptions[queryCacheKey];\n    if (!querySubState || querySubState.status === QueryStatus.uninitialized) {\n      return;\n    }\n    var lowestPollingInterval = findLowestPollingInterval(subscriptions);\n    if (!Number.isFinite(lowestPollingInterval)) {\n      cleanupPollForKey(queryCacheKey);\n      return;\n    }\n    var currentPoll = currentPolls[queryCacheKey];\n    var nextPollTimestamp = Date.now() + lowestPollingInterval;\n    if (!currentPoll || nextPollTimestamp < currentPoll.nextPollTimestamp) {\n      startNextPoll({\n        queryCacheKey: queryCacheKey\n      }, api2);\n    }\n  }\n  function cleanupPollForKey(key) {\n    var existingPoll = currentPolls[key];\n    if (existingPoll == null ? void 0 : existingPoll.timeout) {\n      clearTimeout(existingPoll.timeout);\n    }\n    delete currentPolls[key];\n  }\n  function clearPolls() {\n    for (var _j = 0, _k = Object.keys(currentPolls); _j < _k.length; _j++) {\n      var key = _k[_j];\n      cleanupPollForKey(key);\n    }\n  }\n  function findLowestPollingInterval(subscribers) {\n    if (subscribers === void 0) {\n      subscribers = {};\n    }\n    var lowestPollingInterval = Number.POSITIVE_INFINITY;\n    for (var key in subscribers) {\n      if (!!subscribers[key].pollingInterval) {\n        lowestPollingInterval = Math.min(subscribers[key].pollingInterval, lowestPollingInterval);\n      }\n    }\n    return lowestPollingInterval;\n  }\n  return handler;\n};\n// src/query/core/buildMiddleware/windowEventHandling.ts\nvar buildWindowEventHandler = function (_j) {\n  var reducerPath = _j.reducerPath,\n    context = _j.context,\n    api = _j.api,\n    refetchQuery = _j.refetchQuery,\n    internalState = _j.internalState;\n  var removeQueryResult = api.internalActions.removeQueryResult;\n  var handler = function (action, mwApi) {\n    if (onFocus.match(action)) {\n      refetchValidQueries(mwApi, \"refetchOnFocus\");\n    }\n    if (onOnline.match(action)) {\n      refetchValidQueries(mwApi, \"refetchOnReconnect\");\n    }\n  };\n  function refetchValidQueries(api2, type) {\n    var state = api2.getState()[reducerPath];\n    var queries = state.queries;\n    var subscriptions = internalState.currentSubscriptions;\n    context.batch(function () {\n      for (var _j = 0, _k = Object.keys(subscriptions); _j < _k.length; _j++) {\n        var queryCacheKey = _k[_j];\n        var querySubState = queries[queryCacheKey];\n        var subscriptionSubState = subscriptions[queryCacheKey];\n        if (!subscriptionSubState || !querySubState) continue;\n        var shouldRefetch = Object.values(subscriptionSubState).some(function (sub) {\n          return sub[type] === true;\n        }) || Object.values(subscriptionSubState).every(function (sub) {\n          return sub[type] === void 0;\n        }) && state.config[type];\n        if (shouldRefetch) {\n          if (Object.keys(subscriptionSubState).length === 0) {\n            api2.dispatch(removeQueryResult({\n              queryCacheKey: queryCacheKey\n            }));\n          } else if (querySubState.status !== QueryStatus.uninitialized) {\n            api2.dispatch(refetchQuery(querySubState, queryCacheKey));\n          }\n        }\n      }\n    });\n  }\n  return handler;\n};\n// src/query/core/buildMiddleware/cacheLifecycle.ts\nimport { isAsyncThunkAction, isFulfilled as isFulfilled4 } from \"@reduxjs/toolkit\";\nvar neverResolvedError = new Error(\"Promise never resolved before cacheEntryRemoved.\");\nvar buildCacheLifecycleHandler = function (_j) {\n  var api = _j.api,\n    reducerPath = _j.reducerPath,\n    context = _j.context,\n    queryThunk = _j.queryThunk,\n    mutationThunk = _j.mutationThunk,\n    internalState = _j.internalState;\n  var isQueryThunk = isAsyncThunkAction(queryThunk);\n  var isMutationThunk = isAsyncThunkAction(mutationThunk);\n  var isFulfilledThunk = isFulfilled4(queryThunk, mutationThunk);\n  var lifecycleMap = {};\n  var handler = function (action, mwApi, stateBefore) {\n    var cacheKey = getCacheKey(action);\n    if (queryThunk.pending.match(action)) {\n      var oldState = stateBefore[reducerPath].queries[cacheKey];\n      var state = mwApi.getState()[reducerPath].queries[cacheKey];\n      if (!oldState && state) {\n        handleNewKey(action.meta.arg.endpointName, action.meta.arg.originalArgs, cacheKey, mwApi, action.meta.requestId);\n      }\n    } else if (mutationThunk.pending.match(action)) {\n      var state = mwApi.getState()[reducerPath].mutations[cacheKey];\n      if (state) {\n        handleNewKey(action.meta.arg.endpointName, action.meta.arg.originalArgs, cacheKey, mwApi, action.meta.requestId);\n      }\n    } else if (isFulfilledThunk(action)) {\n      var lifecycle = lifecycleMap[cacheKey];\n      if (lifecycle == null ? void 0 : lifecycle.valueResolved) {\n        lifecycle.valueResolved({\n          data: action.payload,\n          meta: action.meta.baseQueryMeta\n        });\n        delete lifecycle.valueResolved;\n      }\n    } else if (api.internalActions.removeQueryResult.match(action) || api.internalActions.removeMutationResult.match(action)) {\n      var lifecycle = lifecycleMap[cacheKey];\n      if (lifecycle) {\n        delete lifecycleMap[cacheKey];\n        lifecycle.cacheEntryRemoved();\n      }\n    } else if (api.util.resetApiState.match(action)) {\n      for (var _j = 0, _k = Object.entries(lifecycleMap); _j < _k.length; _j++) {\n        var _l = _k[_j],\n          cacheKey2 = _l[0],\n          lifecycle = _l[1];\n        delete lifecycleMap[cacheKey2];\n        lifecycle.cacheEntryRemoved();\n      }\n    }\n  };\n  function getCacheKey(action) {\n    if (isQueryThunk(action)) return action.meta.arg.queryCacheKey;\n    if (isMutationThunk(action)) return action.meta.requestId;\n    if (api.internalActions.removeQueryResult.match(action)) return action.payload.queryCacheKey;\n    if (api.internalActions.removeMutationResult.match(action)) return getMutationCacheKey(action.payload);\n    return \"\";\n  }\n  function handleNewKey(endpointName, originalArgs, queryCacheKey, mwApi, requestId) {\n    var endpointDefinition = context.endpointDefinitions[endpointName];\n    var onCacheEntryAdded = endpointDefinition == null ? void 0 : endpointDefinition.onCacheEntryAdded;\n    if (!onCacheEntryAdded) return;\n    var lifecycle = {};\n    var cacheEntryRemoved = new Promise(function (resolve) {\n      lifecycle.cacheEntryRemoved = resolve;\n    });\n    var cacheDataLoaded = Promise.race([new Promise(function (resolve) {\n      lifecycle.valueResolved = resolve;\n    }), cacheEntryRemoved.then(function () {\n      throw neverResolvedError;\n    })]);\n    cacheDataLoaded.catch(function () {});\n    lifecycleMap[queryCacheKey] = lifecycle;\n    var selector = api.endpoints[endpointName].select(endpointDefinition.type === DefinitionType.query ? originalArgs : queryCacheKey);\n    var extra = mwApi.dispatch(function (_, __, extra2) {\n      return extra2;\n    });\n    var lifecycleApi = __spreadProps(__spreadValues({}, mwApi), {\n      getCacheEntry: function () {\n        return selector(mwApi.getState());\n      },\n      requestId: requestId,\n      extra: extra,\n      updateCachedData: endpointDefinition.type === DefinitionType.query ? function (updateRecipe) {\n        return mwApi.dispatch(api.util.updateQueryData(endpointName, originalArgs, updateRecipe));\n      } : void 0,\n      cacheDataLoaded: cacheDataLoaded,\n      cacheEntryRemoved: cacheEntryRemoved\n    });\n    var runningHandler = onCacheEntryAdded(originalArgs, lifecycleApi);\n    Promise.resolve(runningHandler).catch(function (e) {\n      if (e === neverResolvedError) return;\n      throw e;\n    });\n  }\n  return handler;\n};\n// src/query/core/buildMiddleware/queryLifecycle.ts\nimport { isPending as isPending2, isRejected as isRejected2, isFulfilled as isFulfilled5 } from \"@reduxjs/toolkit\";\nvar buildQueryLifecycleHandler = function (_j) {\n  var api = _j.api,\n    context = _j.context,\n    queryThunk = _j.queryThunk,\n    mutationThunk = _j.mutationThunk;\n  var isPendingThunk = isPending2(queryThunk, mutationThunk);\n  var isRejectedThunk = isRejected2(queryThunk, mutationThunk);\n  var isFullfilledThunk = isFulfilled5(queryThunk, mutationThunk);\n  var lifecycleMap = {};\n  var handler = function (action, mwApi) {\n    var _a, _b, _c;\n    if (isPendingThunk(action)) {\n      var _j = action.meta,\n        requestId = _j.requestId,\n        _k = _j.arg,\n        endpointName_1 = _k.endpointName,\n        originalArgs_1 = _k.originalArgs;\n      var endpointDefinition = context.endpointDefinitions[endpointName_1];\n      var onQueryStarted = endpointDefinition == null ? void 0 : endpointDefinition.onQueryStarted;\n      if (onQueryStarted) {\n        var lifecycle_1 = {};\n        var queryFulfilled = new Promise(function (resolve, reject) {\n          lifecycle_1.resolve = resolve;\n          lifecycle_1.reject = reject;\n        });\n        queryFulfilled.catch(function () {});\n        lifecycleMap[requestId] = lifecycle_1;\n        var selector_1 = api.endpoints[endpointName_1].select(endpointDefinition.type === DefinitionType.query ? originalArgs_1 : requestId);\n        var extra = mwApi.dispatch(function (_, __, extra2) {\n          return extra2;\n        });\n        var lifecycleApi = __spreadProps(__spreadValues({}, mwApi), {\n          getCacheEntry: function () {\n            return selector_1(mwApi.getState());\n          },\n          requestId: requestId,\n          extra: extra,\n          updateCachedData: endpointDefinition.type === DefinitionType.query ? function (updateRecipe) {\n            return mwApi.dispatch(api.util.updateQueryData(endpointName_1, originalArgs_1, updateRecipe));\n          } : void 0,\n          queryFulfilled: queryFulfilled\n        });\n        onQueryStarted(originalArgs_1, lifecycleApi);\n      }\n    } else if (isFullfilledThunk(action)) {\n      var _l = action.meta,\n        requestId = _l.requestId,\n        baseQueryMeta = _l.baseQueryMeta;\n      (_a = lifecycleMap[requestId]) == null ? void 0 : _a.resolve({\n        data: action.payload,\n        meta: baseQueryMeta\n      });\n      delete lifecycleMap[requestId];\n    } else if (isRejectedThunk(action)) {\n      var _m = action.meta,\n        requestId = _m.requestId,\n        rejectedWithValue = _m.rejectedWithValue,\n        baseQueryMeta = _m.baseQueryMeta;\n      (_c = lifecycleMap[requestId]) == null ? void 0 : _c.reject({\n        error: (_b = action.payload) != null ? _b : action.error,\n        isUnhandledError: !rejectedWithValue,\n        meta: baseQueryMeta\n      });\n      delete lifecycleMap[requestId];\n    }\n  };\n  return handler;\n};\n// src/query/core/buildMiddleware/devMiddleware.ts\nvar buildDevCheckHandler = function (_j) {\n  var api = _j.api,\n    apiUid = _j.context.apiUid,\n    reducerPath = _j.reducerPath;\n  return function (action, mwApi) {\n    var _a, _b;\n    if (api.util.resetApiState.match(action)) {\n      mwApi.dispatch(api.internalActions.middlewareRegistered(apiUid));\n    }\n    if (typeof process !== \"undefined\" && process.env.NODE_ENV === \"development\") {\n      if (api.internalActions.middlewareRegistered.match(action) && action.payload === apiUid && ((_b = (_a = mwApi.getState()[reducerPath]) == null ? void 0 : _a.config) == null ? void 0 : _b.middlewareRegistered) === \"conflict\") {\n        console.warn(\"There is a mismatch between slice and middleware for the reducerPath \\\"\" + reducerPath + \"\\\".\\nYou can only have one api per reducer path, this will lead to crashes in various situations!\" + (reducerPath === \"api\" ? \"\\nIf you have multiple apis, you *have* to specify the reducerPath option when using createApi!\" : \"\"));\n      }\n    }\n  };\n};\n// src/query/core/buildMiddleware/batchActions.ts\nimport { produceWithPatches as produceWithPatches2 } from \"immer\";\nvar promise;\nvar queueMicrotaskShim = typeof queueMicrotask === \"function\" ? queueMicrotask.bind(typeof window !== \"undefined\" ? window : typeof global !== \"undefined\" ? global : globalThis) : function (cb) {\n  return (promise || (promise = Promise.resolve())).then(cb).catch(function (err) {\n    return setTimeout(function () {\n      throw err;\n    }, 0);\n  });\n};\nvar buildBatchedActionsHandler = function (_j) {\n  var api = _j.api,\n    queryThunk = _j.queryThunk,\n    internalState = _j.internalState;\n  var subscriptionsPrefix = api.reducerPath + \"/subscriptions\";\n  var previousSubscriptions = null;\n  var dispatchQueued = false;\n  var _k = api.internalActions,\n    updateSubscriptionOptions = _k.updateSubscriptionOptions,\n    unsubscribeQueryResult = _k.unsubscribeQueryResult;\n  var actuallyMutateSubscriptions = function (mutableState, action) {\n    var _a, _b, _c, _d, _e, _f, _g, _h, _i;\n    if (updateSubscriptionOptions.match(action)) {\n      var _j = action.payload,\n        queryCacheKey = _j.queryCacheKey,\n        requestId = _j.requestId,\n        options = _j.options;\n      if ((_a = mutableState == null ? void 0 : mutableState[queryCacheKey]) == null ? void 0 : _a[requestId]) {\n        mutableState[queryCacheKey][requestId] = options;\n      }\n      return true;\n    }\n    if (unsubscribeQueryResult.match(action)) {\n      var _k = action.payload,\n        queryCacheKey = _k.queryCacheKey,\n        requestId = _k.requestId;\n      if (mutableState[queryCacheKey]) {\n        delete mutableState[queryCacheKey][requestId];\n      }\n      return true;\n    }\n    if (api.internalActions.removeQueryResult.match(action)) {\n      delete mutableState[action.payload.queryCacheKey];\n      return true;\n    }\n    if (queryThunk.pending.match(action)) {\n      var _l = action.meta,\n        arg = _l.arg,\n        requestId = _l.requestId;\n      if (arg.subscribe) {\n        var substate = (_c = mutableState[_b = arg.queryCacheKey]) != null ? _c : mutableState[_b] = {};\n        substate[requestId] = (_e = (_d = arg.subscriptionOptions) != null ? _d : substate[requestId]) != null ? _e : {};\n        return true;\n      }\n    }\n    if (queryThunk.rejected.match(action)) {\n      var _m = action.meta,\n        condition = _m.condition,\n        arg = _m.arg,\n        requestId = _m.requestId;\n      if (condition && arg.subscribe) {\n        var substate = (_g = mutableState[_f = arg.queryCacheKey]) != null ? _g : mutableState[_f] = {};\n        substate[requestId] = (_i = (_h = arg.subscriptionOptions) != null ? _h : substate[requestId]) != null ? _i : {};\n        return true;\n      }\n    }\n    return false;\n  };\n  return function (action, mwApi) {\n    var _a, _b;\n    if (!previousSubscriptions) {\n      previousSubscriptions = JSON.parse(JSON.stringify(internalState.currentSubscriptions));\n    }\n    if (api.util.resetApiState.match(action)) {\n      previousSubscriptions = internalState.currentSubscriptions = {};\n      return [true, false];\n    }\n    if (api.internalActions.internal_probeSubscription.match(action)) {\n      var _j = action.payload,\n        queryCacheKey = _j.queryCacheKey,\n        requestId = _j.requestId;\n      var hasSubscription = !!((_a = internalState.currentSubscriptions[queryCacheKey]) == null ? void 0 : _a[requestId]);\n      return [false, hasSubscription];\n    }\n    var didMutate = actuallyMutateSubscriptions(internalState.currentSubscriptions, action);\n    if (didMutate) {\n      if (!dispatchQueued) {\n        queueMicrotaskShim(function () {\n          var newSubscriptions = JSON.parse(JSON.stringify(internalState.currentSubscriptions));\n          var _j = produceWithPatches2(previousSubscriptions, function () {\n              return newSubscriptions;\n            }),\n            patches = _j[1];\n          mwApi.next(api.internalActions.subscriptionsUpdated(patches));\n          previousSubscriptions = newSubscriptions;\n          dispatchQueued = false;\n        });\n        dispatchQueued = true;\n      }\n      var isSubscriptionSliceAction = !!((_b = action.type) == null ? void 0 : _b.startsWith(subscriptionsPrefix));\n      var isAdditionalSubscriptionAction = queryThunk.rejected.match(action) && action.meta.condition && !!action.meta.arg.subscribe;\n      var actionShouldContinue = !isSubscriptionSliceAction && !isAdditionalSubscriptionAction;\n      return [actionShouldContinue, false];\n    }\n    return [true, false];\n  };\n};\n// src/query/core/buildMiddleware/index.ts\nfunction buildMiddleware(input) {\n  var reducerPath = input.reducerPath,\n    queryThunk = input.queryThunk,\n    api = input.api,\n    context = input.context;\n  var apiUid = context.apiUid;\n  var actions = {\n    invalidateTags: createAction3(reducerPath + \"/invalidateTags\")\n  };\n  var isThisApiSliceAction = function (action) {\n    return !!action && typeof action.type === \"string\" && action.type.startsWith(reducerPath + \"/\");\n  };\n  var handlerBuilders = [buildDevCheckHandler, buildCacheCollectionHandler, buildInvalidationByTagsHandler, buildPollingHandler, buildCacheLifecycleHandler, buildQueryLifecycleHandler];\n  var middleware = function (mwApi) {\n    var initialized2 = false;\n    var internalState = {\n      currentSubscriptions: {}\n    };\n    var builderArgs = __spreadProps(__spreadValues({}, input), {\n      internalState: internalState,\n      refetchQuery: refetchQuery\n    });\n    var handlers = handlerBuilders.map(function (build) {\n      return build(builderArgs);\n    });\n    var batchedActionsHandler = buildBatchedActionsHandler(builderArgs);\n    var windowEventsHandler = buildWindowEventHandler(builderArgs);\n    return function (next) {\n      return function (action) {\n        if (!initialized2) {\n          initialized2 = true;\n          mwApi.dispatch(api.internalActions.middlewareRegistered(apiUid));\n        }\n        var mwApiWithNext = __spreadProps(__spreadValues({}, mwApi), {\n          next: next\n        });\n        var stateBefore = mwApi.getState();\n        var _j = batchedActionsHandler(action, mwApiWithNext, stateBefore),\n          actionShouldContinue = _j[0],\n          hasSubscription = _j[1];\n        var res;\n        if (actionShouldContinue) {\n          res = next(action);\n        } else {\n          res = hasSubscription;\n        }\n        if (!!mwApi.getState()[reducerPath]) {\n          windowEventsHandler(action, mwApiWithNext, stateBefore);\n          if (isThisApiSliceAction(action) || context.hasRehydrationInfo(action)) {\n            for (var _k = 0, handlers_1 = handlers; _k < handlers_1.length; _k++) {\n              var handler = handlers_1[_k];\n              handler(action, mwApiWithNext, stateBefore);\n            }\n          }\n        }\n        return res;\n      };\n    };\n  };\n  return {\n    middleware: middleware,\n    actions: actions\n  };\n  function refetchQuery(querySubState, queryCacheKey, override) {\n    if (override === void 0) {\n      override = {};\n    }\n    return queryThunk(__spreadValues({\n      type: \"query\",\n      endpointName: querySubState.endpointName,\n      originalArgs: querySubState.originalArgs,\n      subscribe: false,\n      forceRefetch: true,\n      queryCacheKey: queryCacheKey\n    }, override));\n  }\n}\n// src/query/tsHelpers.ts\nfunction assertCast(v) {}\nfunction safeAssign(target) {\n  var args = [];\n  for (var _j = 1; _j < arguments.length; _j++) {\n    args[_j - 1] = arguments[_j];\n  }\n  Object.assign.apply(Object, __spreadArray([target], args));\n}\n// src/query/core/module.ts\nimport { enablePatches } from \"immer\";\nvar coreModuleName = /* @__PURE__ */Symbol();\nvar coreModule = function () {\n  return {\n    name: coreModuleName,\n    init: function (api, _j, context) {\n      var baseQuery = _j.baseQuery,\n        tagTypes = _j.tagTypes,\n        reducerPath = _j.reducerPath,\n        serializeQueryArgs = _j.serializeQueryArgs,\n        keepUnusedDataFor = _j.keepUnusedDataFor,\n        refetchOnMountOrArgChange = _j.refetchOnMountOrArgChange,\n        refetchOnFocus = _j.refetchOnFocus,\n        refetchOnReconnect = _j.refetchOnReconnect;\n      enablePatches();\n      assertCast(serializeQueryArgs);\n      var assertTagType = function (tag) {\n        if (typeof process !== \"undefined\" && process.env.NODE_ENV === \"development\") {\n          if (!tagTypes.includes(tag.type)) {\n            console.error(\"Tag type '\" + tag.type + \"' was used, but not specified in `tagTypes`!\");\n          }\n        }\n        return tag;\n      };\n      Object.assign(api, {\n        reducerPath: reducerPath,\n        endpoints: {},\n        internalActions: {\n          onOnline: onOnline,\n          onOffline: onOffline,\n          onFocus: onFocus,\n          onFocusLost: onFocusLost\n        },\n        util: {}\n      });\n      var _k = buildThunks({\n          baseQuery: baseQuery,\n          reducerPath: reducerPath,\n          context: context,\n          api: api,\n          serializeQueryArgs: serializeQueryArgs,\n          assertTagType: assertTagType\n        }),\n        queryThunk = _k.queryThunk,\n        mutationThunk = _k.mutationThunk,\n        patchQueryData = _k.patchQueryData,\n        updateQueryData = _k.updateQueryData,\n        upsertQueryData = _k.upsertQueryData,\n        prefetch = _k.prefetch,\n        buildMatchThunkActions = _k.buildMatchThunkActions;\n      var _l = buildSlice({\n          context: context,\n          queryThunk: queryThunk,\n          mutationThunk: mutationThunk,\n          reducerPath: reducerPath,\n          assertTagType: assertTagType,\n          config: {\n            refetchOnFocus: refetchOnFocus,\n            refetchOnReconnect: refetchOnReconnect,\n            refetchOnMountOrArgChange: refetchOnMountOrArgChange,\n            keepUnusedDataFor: keepUnusedDataFor,\n            reducerPath: reducerPath\n          }\n        }),\n        reducer = _l.reducer,\n        sliceActions = _l.actions;\n      safeAssign(api.util, {\n        patchQueryData: patchQueryData,\n        updateQueryData: updateQueryData,\n        upsertQueryData: upsertQueryData,\n        prefetch: prefetch,\n        resetApiState: sliceActions.resetApiState\n      });\n      safeAssign(api.internalActions, sliceActions);\n      var _m = buildMiddleware({\n          reducerPath: reducerPath,\n          context: context,\n          queryThunk: queryThunk,\n          mutationThunk: mutationThunk,\n          api: api,\n          assertTagType: assertTagType\n        }),\n        middleware = _m.middleware,\n        middlewareActions = _m.actions;\n      safeAssign(api.util, middlewareActions);\n      safeAssign(api, {\n        reducer: reducer,\n        middleware: middleware\n      });\n      var _o = buildSelectors({\n          serializeQueryArgs: serializeQueryArgs,\n          reducerPath: reducerPath\n        }),\n        buildQuerySelector = _o.buildQuerySelector,\n        buildMutationSelector = _o.buildMutationSelector,\n        selectInvalidatedBy = _o.selectInvalidatedBy;\n      safeAssign(api.util, {\n        selectInvalidatedBy: selectInvalidatedBy\n      });\n      var _p = buildInitiate({\n          queryThunk: queryThunk,\n          mutationThunk: mutationThunk,\n          api: api,\n          serializeQueryArgs: serializeQueryArgs,\n          context: context\n        }),\n        buildInitiateQuery = _p.buildInitiateQuery,\n        buildInitiateMutation = _p.buildInitiateMutation,\n        getRunningMutationThunk = _p.getRunningMutationThunk,\n        getRunningMutationsThunk = _p.getRunningMutationsThunk,\n        getRunningQueriesThunk = _p.getRunningQueriesThunk,\n        getRunningQueryThunk = _p.getRunningQueryThunk,\n        getRunningOperationPromises = _p.getRunningOperationPromises,\n        removalWarning = _p.removalWarning;\n      safeAssign(api.util, {\n        getRunningOperationPromises: getRunningOperationPromises,\n        getRunningOperationPromise: removalWarning,\n        getRunningMutationThunk: getRunningMutationThunk,\n        getRunningMutationsThunk: getRunningMutationsThunk,\n        getRunningQueryThunk: getRunningQueryThunk,\n        getRunningQueriesThunk: getRunningQueriesThunk\n      });\n      return {\n        name: coreModuleName,\n        injectEndpoint: function (endpointName, definition) {\n          var _a, _b;\n          var anyApi = api;\n          (_b = (_a = anyApi.endpoints)[endpointName]) != null ? _b : _a[endpointName] = {};\n          if (isQueryDefinition(definition)) {\n            safeAssign(anyApi.endpoints[endpointName], {\n              name: endpointName,\n              select: buildQuerySelector(endpointName, definition),\n              initiate: buildInitiateQuery(endpointName, definition)\n            }, buildMatchThunkActions(queryThunk, endpointName));\n          } else if (isMutationDefinition(definition)) {\n            safeAssign(anyApi.endpoints[endpointName], {\n              name: endpointName,\n              select: buildMutationSelector(),\n              initiate: buildInitiateMutation(endpointName)\n            }, buildMatchThunkActions(mutationThunk, endpointName));\n          }\n        }\n      };\n    }\n  };\n};\n// src/query/core/index.ts\nvar createApi = /* @__PURE__ */buildCreateApi(coreModule());\nexport { QueryStatus, buildCreateApi, copyWithStructuralSharing, coreModule, coreModuleName, createApi, defaultSerializeQueryArgs, fakeBaseQuery, fetchBaseQuery, retry, setupListeners, skipSelector, skipToken };","map":null,"metadata":{},"sourceType":"module"}